<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>文件浏览器</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script>
    (() => {
      const STORAGE_KEY = 'ui.fontSizePx';
      const MIN_FONT_SIZE = 14;
      const MAX_FONT_SIZE = 28;
      const FONT_SIZE_STEP = 1;

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
	      const applyFontSize = (value, persist) => {
	        const fontPx = clamp(Math.round(value), MIN_FONT_SIZE, MAX_FONT_SIZE);
	        document.documentElement.style.setProperty('--ui-font-size', `${fontPx}px`);
	        window.__UI_FONT_SIZE_PX__ = fontPx;
	        try {
	          if (typeof window.__RUSTREADER_ON_FONT_SIZE_CHANGE__ === 'function') {
	            window.__RUSTREADER_ON_FONT_SIZE_CHANGE__(fontPx);
	          }
	        } catch {}
	        if (persist) {
	          try {
	            localStorage.setItem(STORAGE_KEY, String(fontPx));
	          } catch {}
	        }
	      };

      const computeDefaultFontSize = () => {
        const dpr = Number(window.devicePixelRatio) || 1;
        const screenWidth = Number(window.screen?.width) || 0;
        const screenHeight = Number(window.screen?.height) || 0;
        const maxSide = Math.max(screenWidth, screenHeight);

        if (dpr >= 1.25) return 16;
        if (maxSide >= 3800) return 20;
        if (maxSide >= 2560) return 18;
        return 16;
      };

      const defaultFontSize = computeDefaultFontSize();
      let initialFontSize = defaultFontSize;

      try {
        const stored = Number(localStorage.getItem(STORAGE_KEY));
        if (Number.isFinite(stored)) initialFontSize = stored;
      } catch {}

      applyFontSize(initialFontSize, false);

      window.addEventListener('keydown', (event) => {
        const modifierDown = event.ctrlKey || event.metaKey;
        if (!modifierDown || event.altKey) return;

        const current = Number(window.__UI_FONT_SIZE_PX__) || defaultFontSize;

        if (event.key === '=' || event.key === '+') {
          event.preventDefault();
          applyFontSize(current + FONT_SIZE_STEP, true);
        } else if (event.key === '-' || event.key === '_') {
          event.preventDefault();
          applyFontSize(current - FONT_SIZE_STEP, true);
        } else if (event.key === '0') {
          event.preventDefault();
          try {
            localStorage.removeItem(STORAGE_KEY);
          } catch {}
          applyFontSize(defaultFontSize, false);
        }
      });
    })();
  </script>

  <!-- Custom Styles -->
  <link rel="stylesheet" href="assets/styles.css" />

  <!-- Library Styles -->
  <link rel="stylesheet" href="assets/docx-preview.min.css" />
  <link rel="stylesheet" href="assets/xspreadsheet.css" />
	  <link rel="stylesheet" href="assets/pptxjs.css" />
	  <link rel="stylesheet" href="assets/nv.d3.min.css" />
	  <link rel="stylesheet" href="assets/highlight-github.min.css" />
	  <link rel="stylesheet" href="assets/katex.min.css" />
	  <link rel="stylesheet" href="assets/marpit-default.css" />
	  <link rel="stylesheet" href="assets/github-markdown.css">
	</head>
<body>

	  <header class="header">
	    <div class="header__container">
	      <div class="header__left">
	        <a href="#" class="header__brand">
	          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
	            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
	            <polyline points="14 2 14 8 20 8"></polyline>
	            <line x1="16" y1="13" x2="8" y2="13"></line>
	            <line x1="16" y1="17" x2="8" y2="17"></line>
	            <polyline points="10 9 9 9 8 9"></polyline>
	          </svg>
	          <span id="brandText">文件浏览器</span></a>

	        <div class="header__actions">
	          <div class="nav__more header__open-menu">
	            <button id="openMenuBtn" type="button" class="btn btn--ghost btn-sm" aria-haspopup="menu" aria-expanded="false" title="打开文件或文件夹">
	              <span id="openMenuBtnLabel">打开</span>
	              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: 0.25rem;">
	                <path stroke-linecap="round" stroke-linejoin="round" d="M6 9l6 6 6-6" />
	              </svg>
		            </button>
		            <div id="openMenuDropdown" class="nav__dropdown" role="menu" aria-label="打开菜单">
		              <button id="openFolderBtn" type="button" class="nav__dropdown-item">打开文件夹...</button>
		              <button id="openFileBtn" type="button" class="nav__dropdown-item">打开文件...</button>
		              <div class="nav__dropdown-separator" aria-hidden="true"></div>
		              <button id="openRecentBtn" type="button" class="nav__dropdown-item nav__dropdown-item--submenu">
		                <span id="openRecentBtnLabel">打开最近</span>
		                <span class="nav__dropdown-count">›</span>
		              </button>
		              <div id="openRecentDropdown" class="nav__dropdown nav__dropdown--submenu" role="menu" aria-label="打开最近"></div>
		            </div>
			          </div>
			          <button id="langToggleBtn" type="button" class="btn btn--ghost btn-sm" aria-label="切换语言" title="切换语言">EN</button>
			          <button id="aboutBtn" type="button" class="btn btn--ghost btn-sm" aria-label="关于" title="关于">关于</button>
			          <input id="openFileInput" class="file-input" type="file" multiple />
		          <input id="openFolderInput" class="file-input" type="file" webkitdirectory directory multiple />
		        </div>
		      </div>

	      <div class="header__right">
	        <button id="menuToggle" class="header__toggle" aria-label="Toggle menu">
	          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
	            <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
	          </svg>
	        </button>
	        <nav id="categoryFilters" class="header__nav nav__list"></nav>
	      </div>
	    </div>
	  </header>

  <main class="main">
    <aside class="sidebar">
      <div class="sidebar__header">
        <h2 id="treeTitle" style="font-size: 0.875rem; margin-bottom: 0.5rem;">目录树</h2>
        <div class="input-group">
          <input id="treeSearchInput" type="text" class="input" placeholder="搜索文件..." />
          <button id="treeSearchClear" type="button" class="input-icon hidden" style="background:none; border:none;">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
          </button>
        </div>
        <div id="treeMeta" class="text-xs text-muted mt-2"></div>
      </div>
      <div id="treeContainer" class="sidebar__content tree-container"></div>
    </aside>

    <section class="preview">
      <div class="fullscreen-trigger"></div>
      <button id="mainSidebarToggle" class="sidebar-toggle" title="切换目录栏">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
      </button>
      <div class="preview__header">
        <div class="flex-col" style="margin-left: 2.5rem;"> <!-- Added margin for toggle button -->
          <h2 id="previewTitle" style="font-size: 0.875rem;">请选择文件</h2>
          <p id="previewSubtitle" class="text-xs text-muted">在左侧树中选择任意文件，即可在此预览。</p>
        </div>
        <div class="flex-row gap-2" style="display: flex;">
          <button id="prevBtn" class="btn btn--ghost btn-sm" title="上一项">↑</button>
          <button id="nextBtn" class="btn btn--ghost btn-sm" title="下一项">↓</button>
          
          <button id="toggleFullscreenBtn" type="button" class="btn btn--primary btn-sm" aria-label="全屏显示">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3m-18 0v3a2 2 0 0 0 2 2h3"/>
            </svg>
          </button>
        </div>
      </div>

      <div class="preview__content">
        <div id="imagePreviewWrapper" class="image-preview hidden">
          <figure id="zoomContainer" class="image-canvas">
            <img id="singleImage" src="" alt="当前图片" class="single-image">
          </figure>
          <p id="imageHelpText" class="text-xs text-muted" style="text-align: right; margin-top: 0.5rem;">滚轮缩放 · 拖拽平移 · 双击重置</p>
        </div>
        <div id="docPreview" class="w-full h-full"></div>
      </div>
    </section>
  </main>

  <script src="assets/marked.min.js"></script>
  <script src="assets/highlight.min.js"></script>
  <script src="assets/jszip.min.js"></script>
  <script src="assets/docx-preview.min.js"></script>
  <script src="assets/xlsx.full.min.js"></script>
  <script src="assets/xspreadsheet.js"></script>
  <script src="assets/jquery-1.11.3.min.js"></script>
  <script src="assets/filereader.js"></script>
  <script src="assets/d3.v7.min.js"></script>
  <script src="assets/markmap-lib.min.js"></script>
  <script src="assets/markmap.min.js"></script>
  <script>
    window.markmap = window.markmap || {};
    window.markmap.autoLoader = Object.assign({}, window.markmap.autoLoader, {
      manual: true,
      baseJs: [],
      baseCss: [],
      provider: 'jsdelivr',
    });
  </script>
  <script src="assets/markmap-autoloader.min.js"></script>
  <script src="assets/drawio-viewer.min.js"></script>
  <script src="assets/d3.v3.min.js"></script>
  <script src="assets/nv.d3.min.js"></script>
	  <script src="assets/dingbat.js"></script>
	  <script src="assets/pptxjs.js"></script>
	  <script src="assets/divs2slides.js"></script>
	  <script src="assets/marpit.min.js"></script>
	  <script src="assets/katex.min.js"></script>
	  <script src="assets/katex-auto-render.min.js"></script>
	
	  <script>
	    // Mobile Menu Toggle
	    const menuToggle = document.getElementById('menuToggle');
    const headerNav = document.getElementById('categoryFilters');
    const mainSidebarToggle = document.getElementById('mainSidebarToggle');
    const mainContainer = document.querySelector('.main');

    if (mainSidebarToggle && mainContainer) {
      mainSidebarToggle.addEventListener('click', () => {
        mainContainer.classList.toggle('sidebar-collapsed');
      });
    }

    if (menuToggle && headerNav) {
      menuToggle.addEventListener('click', () => {
        headerNav.classList.toggle('is-open');
      });
    }

		    const APP_PREFIX = 'rustreader';
		    const APP_AUTHOR = 'uforgetmenot';
		    const APP_GITHUB_URL = 'https://github.com/uforgetmenot/rustreader';
		    const LANGUAGE_STORAGE_KEY = 'ui.language';

	    const I18N = {
		      zh: {
		        siteNameDefault: '文件浏览器',
		        languageLabel: '语言',
		        languageToggleToEn: 'EN',
		        languageToggleToZh: '中文',
		        about: '关于',
		        aboutTitle: '关于',
		        softwareName: '软件名称',
		        author: '作者',
		        githubUrl: 'GitHub',

		        open: '打开',
		        openTitle: '打开文件或文件夹',
		        openMenuLabel: '打开菜单',
		        openFolder: '打开文件夹...',
		        openFile: '打开文件...',
		        openRecent: '打开最近',
		        openRecentMenuLabel: '打开最近',
		        openRecentLoading: '加载中...',
		        openRecentEmpty: '暂无最近记录',
		        openRecentFailed: '加载最近记录失败',

		        treeTitle: '目录树',
		        searchFiles: '搜索文件...',
		        toggleSidebar: '切换目录栏',
	        selectFile: '请选择文件',
	        selectFolder: '请选择文件夹',
	        selectFileHint: '在左侧树中选择任意文件，即可在此预览。',
	        selectFolderHint: '点击顶部“打开”选择文件夹',
	        prevItem: '上一项',
	        nextItem: '下一项',
	        fullscreen: '全屏显示',
	        currentImageAlt: '当前图片',
	        imageHelp: '滚轮缩放 · 拖拽平移 · 双击重置',

	        all: '全部',
	        filterNoMatch: '当前筛选没有匹配文件。',
	        more: '更多',
	        moreFilters: '更多筛选',

	        localPrefix: '本地: ',
	        openedDirectory: '已打开目录',
	        currentDirectory: '当前目录',
	        noFolderSelected: '未选择目录',

	        emptyNoMatch: '无匹配文件',
	        emptyClickOpenFolder: '请点击上方“打开”选择文件夹',
	        emptyNoPreviewable: '所选内容中没有支持预览的文件。',
	        treeMetaNoPreviewable: '没有可预览文件',
	        treeMetaNoMatch: '无匹配文件',
	        treeMetaMatchCount: '匹配 {count} 个文件',

	        toc: '目录',
	        searchToc: '搜索目录...',
	        showToc: '显示目录',

	        loading: '加载中...',
	        unsupportedPreview: '暂不支持预览',
	        loadFailed: '加载失败: {message}',

	        close: '关闭',
	        cancel: '取消',
	        confirm: '确定',
	        invalidPositiveNumber: '请输入有效的正数值',
	        rowHeightTitle: '统一设置行高',
	        colWidthTitle: '统一设置列宽',
	        rowHeightPx: '行高 (像素)',
	        colWidthPx: '列宽 (像素)',

	        setFontColor: '设置字体颜色',
	        setFillColor: '设置填充颜色',
	        rowHeight: '行高',
	        colWidth: '列宽',
	        setAllRowHeights: '统一设置所有行高',
	        setAllColWidths: '统一设置所有列宽',
	        autoRowHeight: '行高自适应',
	        autoColWidth: '列宽自适应',
	        autoFitAll: '一键自适应',
	        autoRowHeightTitle: '根据内容自动调整行高',
	        autoColWidthTitle: '根据内容自动调整列宽',
	        autoFitAllTitle: '自动调整所有行高和列宽',

	        pdfPrev: '上一页',
	        pdfNext: '下一页',
	        pdfJump: '跳转',
	        pdfZoomOut: '缩小',
	        pdfZoomIn: '放大',
	        pdfFitWidth: '适应宽度',
	        pdfToc: '目录',
	        pdfLoading: '正在加载 PDF ...',
	        pdfBookmarks: '书签',
	        pdfBookmarksAria: 'PDF 书签列表',
	        pdfViewBookmarks: '查看书签',
	        pdfClose: '关闭',
	        pdfPageInputPlaceholder: '页码',
	        pdfSearchBookmarks: '搜索书签...',
	        pdfLoadingBookmarks: '加载书签中...',
	        pdfNoMatchingBookmarks: '没有匹配的书签',
	        pdfNoBookmarks: '暂无书签',
	        pdfUntitledBookmark: '未命名书签',
	        pdfPageLabel: '第 {page} 页',
	        pdfRenderStatus: '渲染第 {page} / {total} 页...',
	        pdfLoadFailedRetry: 'PDF 加载失败，正在重试...',
	        pdfLoadFailed: 'PDF 加载失败: {message}',
	        unknownError: '未知错误',

	        wordShowToc: '显示目录',
	        wordTocTitle: '标题目录',
	        wordCloseToc: '关闭目录',
	        wordSearchHeadings: '搜索标题...',
	        wordTocAria: 'Word 标题目录',
	        wordNoMatchingHeadings: '没有匹配的标题',
	        wordNoHeadings: '暂无可用标题',
	        wordNoHeadingsDetected: '未检测到标题',

	        zoomIn: '放大',
	        zoomOut: '缩小',
	        fitWindow: '适应窗口',
	        resetView: '重置视图',

	        marpitNav: '导航目录',

	        openedFolder: '已打开文件夹',
	        openedFiles: '已打开文件',
	        localFolder: '本地文件夹',
	        localFiles: '本地文件',

		        openFolderFailed: '打开文件夹失败: {message}',
		        openFailed: '打开失败: {message}',
		        scanTitle: '正在扫描...',
		        scanDetail: '已扫描 {dirs} 个目录，{files} 个文件，匹配 {matched} 个可预览文件',
		        scanPath: '当前: {path}',

		        missingScriptSrc: '缺少脚本地址',
		        scriptLoadFailed: '脚本加载失败: {src}',
		        pdfJsLoadFailed: 'PDF.js 加载失败',
	      },
		      en: {
		        siteNameDefault: 'File Browser',
		        languageLabel: 'Language',
		        languageToggleToEn: 'EN',
		        languageToggleToZh: '中文',
		        about: 'About',
		        aboutTitle: 'About',
		        softwareName: 'App name',
		        author: 'Author',
		        githubUrl: 'GitHub',

			        open: 'Open',
			        openTitle: 'Open file or folder',
			        openMenuLabel: 'Open menu',
		        openFolder: 'Open folder...',
		        openFile: 'Open file...',
		        openRecent: 'Open recent',
		        openRecentMenuLabel: 'Open recent',
		        openRecentLoading: 'Loading...',
		        openRecentEmpty: 'No recent items',
		        openRecentFailed: 'Failed to load recent items',

		        treeTitle: 'Directory',
		        searchFiles: 'Search files...',
		        toggleSidebar: 'Toggle sidebar',
	        selectFile: 'Select a file',
	        selectFolder: 'Select a folder',
	        selectFileHint: 'Select any file in the tree to preview it here.',
	        selectFolderHint: 'Click “Open” to choose a folder',
	        prevItem: 'Previous',
	        nextItem: 'Next',
	        fullscreen: 'Fullscreen',
	        currentImageAlt: 'Current image',
	        imageHelp: 'Scroll to zoom · Drag to pan · Double-click to reset',

	        all: 'All',
	        filterNoMatch: 'No files match the current filter.',
	        more: 'More',
	        moreFilters: 'More filters',

	        localPrefix: 'Local: ',
	        openedDirectory: 'Opened',
	        currentDirectory: 'Current',
	        noFolderSelected: 'No folder selected',

	        emptyNoMatch: 'No matching files',
	        emptyClickOpenFolder: 'Click “Open” above to choose a folder',
	        emptyNoPreviewable: 'No supported previewable files in the selection.',
	        treeMetaNoPreviewable: 'No previewable files',
	        treeMetaNoMatch: 'No matching files',
	        treeMetaMatchCount: 'Matched {count} files',

	        toc: 'Contents',
	        searchToc: 'Search contents...',
	        showToc: 'Show contents',

	        loading: 'Loading...',
	        unsupportedPreview: 'Preview not supported',
	        loadFailed: 'Load failed: {message}',

	        close: 'Close',
	        cancel: 'Cancel',
	        confirm: 'OK',
	        invalidPositiveNumber: 'Enter a valid positive number',
	        rowHeightTitle: 'Set row height',
	        colWidthTitle: 'Set column width',
	        rowHeightPx: 'Row height (px)',
	        colWidthPx: 'Column width (px)',

	        setFontColor: 'Text color',
	        setFillColor: 'Fill color',
	        rowHeight: 'Row height',
	        colWidth: 'Column width',
	        setAllRowHeights: 'Set all row heights',
	        setAllColWidths: 'Set all column widths',
	        autoRowHeight: 'Auto row height',
	        autoColWidth: 'Auto column width',
	        autoFitAll: 'Auto fit',
	        autoRowHeightTitle: 'Auto fit row heights based on content',
	        autoColWidthTitle: 'Auto fit column widths based on content',
	        autoFitAllTitle: 'Auto fit all row heights and column widths',

	        pdfPrev: 'Previous page',
	        pdfNext: 'Next page',
	        pdfJump: 'Go',
	        pdfZoomOut: 'Zoom out',
	        pdfZoomIn: 'Zoom in',
	        pdfFitWidth: 'Fit width',
	        pdfToc: 'Contents',
	        pdfLoading: 'Loading PDF ...',
	        pdfBookmarks: 'Bookmarks',
	        pdfBookmarksAria: 'PDF bookmarks',
	        pdfViewBookmarks: 'View bookmarks',
	        pdfClose: 'Close',
	        pdfPageInputPlaceholder: 'Page',
	        pdfSearchBookmarks: 'Search bookmarks...',
	        pdfLoadingBookmarks: 'Loading bookmarks...',
	        pdfNoMatchingBookmarks: 'No matching bookmarks',
	        pdfNoBookmarks: 'No bookmarks',
	        pdfUntitledBookmark: 'Untitled bookmark',
	        pdfPageLabel: 'Page {page}',
	        pdfRenderStatus: 'Rendering page {page} / {total} ...',
	        pdfLoadFailedRetry: 'PDF failed to load, retrying...',
	        pdfLoadFailed: 'PDF load failed: {message}',
	        unknownError: 'Unknown error',

	        wordShowToc: 'Show contents',
	        wordTocTitle: 'Headings',
	        wordCloseToc: 'Close',
	        wordSearchHeadings: 'Search headings...',
	        wordTocAria: 'Word headings',
	        wordNoMatchingHeadings: 'No matching headings',
	        wordNoHeadings: 'No headings available',
	        wordNoHeadingsDetected: 'No headings detected',

	        zoomIn: 'Zoom in',
	        zoomOut: 'Zoom out',
	        fitWindow: 'Fit',
	        resetView: 'Reset view',

	        marpitNav: 'Outline',

	        openedFolder: 'Opened folder',
	        openedFiles: 'Opened files',
	        localFolder: 'Local folder',
	        localFiles: 'Local files',

		        openFolderFailed: 'Failed to open folder: {message}',
		        openFailed: 'Failed to open: {message}',
		        scanTitle: 'Scanning...',
		        scanDetail: 'Scanned {dirs} directories, {files} files, matched {matched} previewable files',
		        scanPath: 'Current: {path}',

		        missingScriptSrc: 'Missing script URL',
		        scriptLoadFailed: 'Failed to load script: {src}',
		        pdfJsLoadFailed: 'Failed to load PDF.js',
	      },
	    };

	    const CATEGORY_ORDER = [
	      'images',
	      'video',
	      'audio',
	      'markdown',
	      'mindmap',
	      'drawio',
	      'marpit',
	      'pdf',
	      'word',
	      'excel',
	      'text',
	      'slides',
	    ];

	    const CATEGORY_CONFIG_BY_LANG = {
	      zh: {
	        images: { label: '图片', helper: '缩略图浏览' },
	        video: { label: '视频', helper: '视频预览' },
	        audio: { label: '音频', helper: '音频预览' },
	        markdown: { label: 'MD', helper: '渲染 Markdown' },
	        mindmap: { label: '思维导图', helper: 'Markmap' },
	        drawio: { label: 'Draw.io', helper: '图表预览' },
	        marpit: { label: 'PPT(MD)', helper: 'Marpit 演示' },
	        pdf: { label: 'PDF', helper: 'PDF 预览' },
	        word: { label: 'Word', helper: 'Docx 渲染' },
	        excel: { label: 'Excel', helper: 'Spreadsheet' },
	        text: { label: 'TXT', helper: '文本预览' },
	        slides: { label: 'PPTX', helper: '幻灯片' },
	      },
	      en: {
	        images: { label: 'Images', helper: 'Thumbnails' },
	        video: { label: 'Video', helper: 'Video preview' },
	        audio: { label: 'Audio', helper: 'Audio preview' },
	        markdown: { label: 'MD', helper: 'Render Markdown' },
	        mindmap: { label: 'Mindmap', helper: 'Markmap' },
	        drawio: { label: 'Draw.io', helper: 'Diagram preview' },
	        marpit: { label: 'PPT(MD)', helper: 'Marpit slides' },
	        pdf: { label: 'PDF', helper: 'PDF preview' },
	        word: { label: 'Word', helper: 'Docx render' },
	        excel: { label: 'Excel', helper: 'Spreadsheet' },
	        text: { label: 'TXT', helper: 'Text preview' },
	        slides: { label: 'PPTX', helper: 'Slides' },
	      },
	    };

	    function normalizeLanguage(value) {
	      const v = String(value || '').toLowerCase();
	      if (v === 'en') return 'en';
	      return 'zh';
	    }

	    function detectLanguage() {
	      try {
	        const stored = localStorage.getItem(LANGUAGE_STORAGE_KEY);
	        if (stored) return normalizeLanguage(stored);
	      } catch {}
	      const navLang = String(navigator.language || '').toLowerCase();
	      if (navLang.startsWith('zh')) return 'zh';
	      return 'en';
	    }

	    let currentLang = detectLanguage();

	    function t(key, vars) {
	      const dict = I18N[currentLang] || I18N.zh;
	      const template = dict[key] || I18N.zh[key] || String(key);
	      if (!vars) return template;
	      return template.replace(/\{(\w+)\}/g, (_, name) => {
	        return vars[name] == null ? '' : String(vars[name]);
	      });
	    }

	    function getCategoryConfig() {
	      return CATEGORY_CONFIG_BY_LANG[currentLang] || CATEGORY_CONFIG_BY_LANG.zh;
	    }

	    function getDefaultSiteNamePart() {
	      return (I18N[currentLang] || I18N.zh).siteNameDefault;
	    }

	    let currentSiteNamePart = null;
	    let currentSiteNameIsDefault = true;

	    function parseSiteNamePartFromTitle(value) {
	      const raw = String(value || '').trim();
	      const prefix = `${APP_PREFIX} - `;
	      if (!raw) return null;
	      if (raw.toLowerCase().startsWith(prefix.toLowerCase())) {
	        const tail = raw.slice(prefix.length).trim();
	        return tail || null;
	      }
	      return raw || null;
	    }

	    function ensureSiteNamePartInitialized() {
	      if (currentSiteNamePart) return;
	      const fromTitle = parseSiteNamePartFromTitle(document.title);
	      currentSiteNamePart = fromTitle || getDefaultSiteNamePart();
	      currentSiteNameIsDefault = (
	        currentSiteNamePart === I18N.zh.siteNameDefault ||
	        currentSiteNamePart === I18N.en.siteNameDefault
	      );
	    }

	    function applyAppTitle(siteNamePart) {
	      const suffix = String(siteNamePart || '').trim() || getDefaultSiteNamePart();
	      try { document.title = suffix; } catch {}
	      if (typeof brandTextEl !== 'undefined' && brandTextEl) {
	        brandTextEl.textContent = suffix;
	      }
	      if (typeof tauriInvoke === 'function') {
	        tauriInvoke('set_app_window_title', { site_name: suffix }).catch(() => {});
	      }
	    }

		    function setLanguage(lang, persist) {
		      currentLang = normalizeLanguage(lang);
		      if (persist) {
		        persistAppConfigPatch({ language: currentLang });
		      }

	      try {
	        document.documentElement.lang = currentLang === 'zh' ? 'zh-CN' : 'en';
	      } catch {}

	      ensureSiteNamePartInitialized();
	      if (currentSiteNameIsDefault) {
	        currentSiteNamePart = getDefaultSiteNamePart();
	      }
	      applyAppTitle(currentSiteNamePart);
	      if (typeof updateCurrentSourceLabel === 'function') updateCurrentSourceLabel();

	      if (typeof openMenuBtn !== 'undefined' && openMenuBtn) {
	        openMenuBtn.title = t('openTitle');
	      }
	      if (typeof openMenuBtnLabel !== 'undefined' && openMenuBtnLabel) {
	        openMenuBtnLabel.textContent = t('open');
	      }
	      if (typeof openMenuDropdown !== 'undefined' && openMenuDropdown) {
	        openMenuDropdown.setAttribute('aria-label', t('openMenuLabel'));
	      }
	      if (typeof openFolderBtn !== 'undefined' && openFolderBtn) {
	        openFolderBtn.textContent = t('openFolder');
	      }
		      if (typeof openFileBtn !== 'undefined' && openFileBtn) {
		        openFileBtn.textContent = t('openFile');
		      }
		      if (typeof openRecentBtnLabel !== 'undefined' && openRecentBtnLabel) {
		        openRecentBtnLabel.textContent = t('openRecent');
		      }
		      if (typeof openRecentDropdown !== 'undefined' && openRecentDropdown) {
		        openRecentDropdown.setAttribute('aria-label', t('openRecentMenuLabel'));
		      }
		      if (typeof treeTitleEl !== 'undefined' && treeTitleEl) {
		        treeTitleEl.textContent = t('treeTitle');
		      }
	      if (typeof treeSearchInput !== 'undefined' && treeSearchInput) {
	        treeSearchInput.placeholder = t('searchFiles');
	      }
	      if (typeof mainSidebarToggle !== 'undefined' && mainSidebarToggle) {
	        mainSidebarToggle.title = t('toggleSidebar');
	      }
	      if (typeof prevBtn !== 'undefined' && prevBtn) {
	        prevBtn.title = t('prevItem');
	      }
	      if (typeof nextBtn !== 'undefined' && nextBtn) {
	        nextBtn.title = t('nextItem');
	      }
	      if (typeof toggleFullscreenBtn !== 'undefined' && toggleFullscreenBtn) {
	        toggleFullscreenBtn.setAttribute('aria-label', t('fullscreen'));
	      }
	      if (typeof singleImage !== 'undefined' && singleImage) {
	        singleImage.alt = t('currentImageAlt');
	      }
	      if (typeof imageHelpTextEl !== 'undefined' && imageHelpTextEl) {
	        imageHelpTextEl.textContent = t('imageHelp');
	      }

		      if (typeof langToggleBtn !== 'undefined' && langToggleBtn) {
		        const nextLabel = currentLang === 'zh' ? t('languageToggleToEn') : t('languageToggleToZh');
		        langToggleBtn.textContent = nextLabel;
		        langToggleBtn.title = t('languageLabel');
		        langToggleBtn.setAttribute('aria-label', t('languageLabel'));
		      }

		      if (typeof aboutBtn !== 'undefined' && aboutBtn) {
		        aboutBtn.textContent = t('about');
		        aboutBtn.title = t('about');
		        aboutBtn.setAttribute('aria-label', t('about'));
		      }

			      if (typeof updateAboutModalLanguage === 'function') updateAboutModalLanguage();
			      if (typeof updateScanOverlayLanguage === 'function') updateScanOverlayLanguage();
			    }

	    const CATEGORY_EXTENSIONS = {
	      images: new Set(['.png', '.jpg', '.jpeg', '.gif', '.webp']),
	      video: new Set(['.mp4', '.webm', '.ogv', '.m4v']),
	      audio: new Set(['.mp3', '.wav', '.m4a', '.ogg', '.oga', '.flac', '.aac']),
	      markdown: new Set(['.md', '.markdown']),
	      drawio: new Set(['.drawio']),
	      pdf: new Set(['.pdf']),
	      word: new Set(['.docx']),
	      excel: new Set(['.xlsx']),
	      text: new Set(['.txt']),
	      slides: new Set(['.pptx']),
	    };

	    function categorizePath(path) {
	      if (!path) return null;
	      const lower = String(path).toLowerCase();
	      if (lower.endsWith('.mm.md')) return 'mindmap';
	      if (lower.endsWith('.ppt.md')) return 'marpit';
	      const dotIndex = lower.lastIndexOf('.');
	      if (dotIndex === -1) return null;
	      const ext = lower.slice(dotIndex);
	      for (const [category, extensions] of Object.entries(CATEGORY_EXTENSIONS)) {
	        if (extensions.has(ext)) return category;
	      }
	      return null;
	    }

	    const MARPIT_CUSTOM_STYLE = `
      .marpit-wrapper {
        background-color: #e5e7eb;
        padding: 30px; /* Reduced padding */
        min-height: 100%;
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: fit-content;
        width: 100%;
        box-sizing: border-box;
      }
      .marpit-wrapper section {
        background-color: #ffffff;
        background-image: radial-gradient(circle at top, rgba(255,255,255,0.95), rgba(248,249,250,0.9));
        border: 1px solid rgba(15,23,42,0.08);
        border-radius: 6px;
        flex-shrink: 0;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.18), 0 4px 10px rgba(15, 23, 42, 0.1);
        padding: 80px 100px; /* Increased padding for larger slides */
        width: 100%;
        max-width: 1024px; /* Increased max-width for better space utilization */
        aspect-ratio: 4 / 3; /* Maintain aspect ratio (1024/768 = 4/3) */
        min-height: auto;
        margin: 10px auto;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
        color: #24292f;
        font-size: 16px;
        line-height: 1.6;
        position: relative;
      }
      
      /* GitHub Theme Elements */
      .marpit-wrapper h1 {
        border-bottom: 1px solid #d0d7de;
        padding-bottom: 0.3em;
        font-size: 36px;
        font-weight: 600;
        margin-bottom: 1.2rem; /* Adjusted margin */
        margin-top: 0;
        color: #1F2328;
      }
      .marpit-wrapper h2 {
        border-bottom: 1px solid #d0d7de;
        padding-bottom: 0.3em;
        font-size: 25px;
        font-weight: 600;
        margin-top: 1.8rem; /* Adjusted margin */
        margin-bottom: 1.2rem; /* Adjusted margin */
        color: #1F2328;
      }
      .marpit-wrapper h3 { font-size: 24px; font-weight: 600; margin-top: 1.1em; margin-bottom: 0.65em; color: #1F2328; }
      .marpit-wrapper h4 { font-size: 23px; font-weight: 600; color: #1F2328; }
      .marpit-wrapper h5 { font-size: 22px; font-weight: 600; color: #1F2328; }
      .marpit-wrapper h6 { font-size: 21px; font-weight: 600; color: #1F2328; letter-spacing: 0.02em; }
      .marpit-wrapper h7,
      .marpit-wrapper h8,
      .marpit-wrapper h9 {
        font-size: 20px;
        font-weight: 600;
        color: #1F2328;
      }
      
      .marpit-wrapper pre {
        background-color: #f6f8fa;
        border-radius: 6px;
        padding: 16px;
        overflow: auto;
      }
      .marpit-wrapper code {
        font-family: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
        font-size: 0.85em;
      }
      .marpit-wrapper blockquote {
        border-left: 0.25em solid #d0d7de;
        color: #57606a;
        padding: 0 1em;
        margin: 1.2em 0; /* Adjusted margin */
      }
      
      .marpit-wrapper ul,
      .marpit-wrapper ol { padding-left: 2em; }
      .marpit-wrapper li { margin-bottom: 0.6em; } /* Adjusted margin */
      .marpit-wrapper img { max-width: 100%; height: auto; display: block; margin: 1.2rem auto; } /* Adjusted margin */
      .marpit-wrapper table { border-collapse: collapse; width: 100%; margin: 1.2rem 0; } /* Adjusted margin */
      .marpit-wrapper th,
      .marpit-wrapper td { border: 1px solid #d0d7de; padding: 6px 13px; }
      .marpit-wrapper th { background-color: #f6f8fa; font-weight: 600; }
      .marpit-wrapper tr:nth-child(2n) { background-color: #f6f8fa; }
    `;

    let fileGroups = [];
    let filteredFiles = [];
    let currentCategory = 'all';
    let currentIndex = 0;
    let treeSearchTerm = '';
    let zoomLevel = 1;
    let translateX = 0;
    let translateY = 0;
    const MIN_ZOOM = 0.1;
    const MAX_ZOOM = 10;
    const DRAWIO_PAN_CANVAS_SIZE = 3200;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let disposePptxViewer = null;
    let marpitInstance = null;
    let disposeDrawioPanSurface = null;
    let resetDrawioPanPosition = null;
    let disposeMarpitNavigation = null;
	    let disposePdfViewer = null;
		    let disposeWordToc = null;
		    let currentWordHeadingStyles = null;
				    let disposeCategoryMoreMenu = null;
				    let aboutModalInstance = null;
				    let persistedAppConfig = { language: null, fontSizePx: null };
				    let persistedAppConfigDirty = { language: false, fontSizePx: false };
				    let appConfigSaveTimer = null;
				    let scanOverlayInstance = null;
				    let activeScanId = null;
				    let scanProgressState = { dirs: 0, files: 0, matched: 0, path: '' };
				    let scanProgressUnlisten = null;
				    const DOCX_STYLE_PREFIX = 'docx';
			    const localFilesByPath = new Map();
		    const diskFilePathsByVirtualPath = new Map();
		    const localObjectUrlsByPath = new Map();
			    const tauriCore = window.__TAURI__ && window.__TAURI__.core ? window.__TAURI__.core : null;
			    const tauriInvoke = tauriCore && typeof tauriCore.invoke === 'function' ? tauriCore.invoke : null;
			    const tauriConvertFileSrc = tauriCore && typeof tauriCore.convertFileSrc === 'function' ? tauriCore.convertFileSrc : null;
			    const tauriEvent = window.__TAURI__ && window.__TAURI__.event ? window.__TAURI__.event : null;
			    let currentSourceKind = 'none';
			    let currentSourceName = '';
		    let currentSourceLabel = '';
		    let hasUserSelection = false;

    // Elements
	    const brandTextEl = document.getElementById('brandText');
	    const categoryFiltersEl = document.getElementById('categoryFilters');
	    const langToggleBtn = document.getElementById('langToggleBtn');
	    const aboutBtn = document.getElementById('aboutBtn');
	    const treeContainer = document.getElementById('treeContainer');
    const treeTitleEl = document.getElementById('treeTitle');
    const treeSearchInput = document.getElementById('treeSearchInput');
    const treeSearchClear = document.getElementById('treeSearchClear');
    const treeMetaEl = document.getElementById('treeMeta');
    const previewTitleEl = document.getElementById('previewTitle');
    const previewSubtitleEl = document.getElementById('previewSubtitle');
    const docPreviewEl = document.getElementById('docPreview');
    const imagePreviewWrapper = document.getElementById('imagePreviewWrapper');
    const imageHelpTextEl = document.getElementById('imageHelpText');
	    const zoomContainer = document.getElementById('zoomContainer');
	    const singleImage = document.getElementById('singleImage');
	    const toggleFullscreenBtn = document.getElementById('toggleFullscreenBtn');
	    const openMenuBtn = document.getElementById('openMenuBtn');
	    const openMenuBtnLabel = document.getElementById('openMenuBtnLabel');
		    const openMenuDropdown = document.getElementById('openMenuDropdown');
		    const openFileBtn = document.getElementById('openFileBtn');
		    const openFolderBtn = document.getElementById('openFolderBtn');
		    const openRecentBtn = document.getElementById('openRecentBtn');
		    const openRecentBtnLabel = document.getElementById('openRecentBtnLabel');
		    const openRecentDropdown = document.getElementById('openRecentDropdown');
		    const openFileInput = document.getElementById('openFileInput');
		    const openFolderInput = document.getElementById('openFolderInput');

		    const prevBtn = document.getElementById('prevBtn');
		    const nextBtn = document.getElementById('nextBtn');
		    const previewCardEl = document.querySelector('.preview');
		    const rootStyle = document.documentElement.style;

		    const APP_CONFIG_SAVE_DEBOUNCE_MS = 200;
		    const FONT_SIZE_STORAGE_KEY = 'ui.fontSizePx';
		    const MIN_FONT_SIZE_PX = 14;
		    const MAX_FONT_SIZE_PX = 28;

		    function clampFontSizePx(value) {
		      const numeric = Math.round(Number(value));
		      if (!Number.isFinite(numeric)) return null;
		      return Math.min(Math.max(numeric, MIN_FONT_SIZE_PX), MAX_FONT_SIZE_PX);
		    }

		    function applyFontSizePx(value) {
		      const fontPx = clampFontSizePx(value);
		      if (!fontPx) return;
		      try {
		        document.documentElement.style.setProperty('--ui-font-size', `${fontPx}px`);
		        window.__UI_FONT_SIZE_PX__ = fontPx;
		      } catch {}
		    }

		    function mergePersistedAppConfig(patch) {
		      if (!patch || typeof patch !== 'object') return;

		      if (typeof patch.language === 'string' && patch.language.trim()) {
		        persistedAppConfig.language = normalizeLanguage(patch.language);
		      }
		      if (patch.fontSizePx != null) {
		        const fontPx = clampFontSizePx(patch.fontSizePx);
		        if (fontPx) persistedAppConfig.fontSizePx = fontPx;
		      }
		    }

		    function scheduleSavePersistedAppConfig() {
		      if (!tauriInvoke) return;
		      if (appConfigSaveTimer) {
		        clearTimeout(appConfigSaveTimer);
		        appConfigSaveTimer = null;
		      }
		      appConfigSaveTimer = setTimeout(() => {
		        appConfigSaveTimer = null;
		        const snapshot = Object.assign({}, persistedAppConfig);
		        tauriInvoke('save_app_config', { config: snapshot }).catch((error) => {
		          console.error('save_app_config failed', error);
		        });
		      }, APP_CONFIG_SAVE_DEBOUNCE_MS);
		    }

		    function persistAppConfigPatch(patch) {
		      if (!patch || typeof patch !== 'object') return;
		      if (Object.prototype.hasOwnProperty.call(patch, 'language')) {
		        persistedAppConfigDirty.language = true;
		      }
		      if (Object.prototype.hasOwnProperty.call(patch, 'fontSizePx')) {
		        persistedAppConfigDirty.fontSizePx = true;
		      }
		      mergePersistedAppConfig(patch);

		      if (persistedAppConfig.language) {
		        try { localStorage.setItem(LANGUAGE_STORAGE_KEY, persistedAppConfig.language); } catch {}
		      }
		      if (persistedAppConfig.fontSizePx) {
		        try { localStorage.setItem(FONT_SIZE_STORAGE_KEY, String(persistedAppConfig.fontSizePx)); } catch {}
		      }

		      scheduleSavePersistedAppConfig();
		    }

		    async function initAppConfigFromDisk() {
		      if (!tauriInvoke) return;
		      let loaded = null;
		      try {
		        loaded = await tauriInvoke('load_app_config');
		      } catch (error) {
		        console.error('load_app_config failed', error);
		        return;
		      }
		      if (!loaded || typeof loaded !== 'object') return;

		      if (!persistedAppConfigDirty.language && typeof loaded.language === 'string') {
		        mergePersistedAppConfig({ language: loaded.language });
		      }
		      if (!persistedAppConfigDirty.fontSizePx && loaded.fontSizePx != null) {
		        mergePersistedAppConfig({ fontSizePx: loaded.fontSizePx });
		      }

		      if (persistedAppConfig.language) {
		        try { localStorage.setItem(LANGUAGE_STORAGE_KEY, persistedAppConfig.language); } catch {}
		      }
		      if (persistedAppConfig.fontSizePx) {
		        try { localStorage.setItem(FONT_SIZE_STORAGE_KEY, String(persistedAppConfig.fontSizePx)); } catch {}
		      }

		      if (!persistedAppConfigDirty.fontSizePx && persistedAppConfig.fontSizePx) {
		        applyFontSizePx(persistedAppConfig.fontSizePx);
		      }

		      if (!persistedAppConfigDirty.language && persistedAppConfig.language) {
		        const nextLang = normalizeLanguage(persistedAppConfig.language);
		        const changed = nextLang !== currentLang;
		        setLanguage(nextLang, false);
		        if (changed) rerenderForLanguageChange();
		      }
		    }

		    window.__RUSTREADER_ON_FONT_SIZE_CHANGE__ = (fontPx) => {
		      const clamped = clampFontSizePx(fontPx);
		      if (!clamped) return;
		      persistAppConfigPatch({ fontSizePx: clamped });
		    };

		    void initAppConfigFromDisk();

		    function generateScanId() {
		      try {
		        if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
		          return crypto.randomUUID();
		        }
		      } catch {}
		      return `scan_${Date.now()}_${Math.random().toString(16).slice(2)}`;
		    }

		    function ensureScanOverlay() {
		      if (scanOverlayInstance || !document?.body) return scanOverlayInstance;

		      const overlay = document.createElement('div');
		      overlay.className = 'xspreadsheet-size-modal';
		      overlay.setAttribute('aria-hidden', 'true');
		      overlay.innerHTML = `
		        <div class="xspreadsheet-size-modal__dialog" role="dialog" aria-modal="true" aria-labelledby="scanOverlayTitle" style="width: min(560px, 100%);">
		          <div class="xspreadsheet-size-modal__title" id="scanOverlayTitle" data-scan-title>${escapeHtml(t('scanTitle'))}</div>
		          <div class="scan-progressbar" aria-hidden="true"><div class="scan-progressbar__bar"></div></div>
		          <div class="text-sm" data-scan-detail style="margin-top: 0.25rem;"></div>
		          <div class="text-xs text-muted" data-scan-path style="margin-top: 0.25rem; word-break: break-all;"></div>
		        </div>
		      `;
		      document.body.appendChild(overlay);

		      const titleEl = overlay.querySelector('[data-scan-title]');
		      const detailEl = overlay.querySelector('[data-scan-detail]');
		      const pathEl = overlay.querySelector('[data-scan-path]');

		      const show = () => {
		        overlay.classList.add('is-open');
		        overlay.setAttribute('aria-hidden', 'false');
		      };
		      const hide = () => {
		        overlay.classList.remove('is-open');
		        overlay.setAttribute('aria-hidden', 'true');
		      };
		      const update = () => {
		        if (titleEl) titleEl.textContent = t('scanTitle');
		        if (detailEl) {
		          detailEl.textContent = t('scanDetail', {
		            dirs: scanProgressState.dirs,
		            files: scanProgressState.files,
		            matched: scanProgressState.matched,
		          });
		        }
		        if (pathEl) {
		          const value = String(scanProgressState.path || '').trim();
		          pathEl.textContent = value ? t('scanPath', { path: value }) : '';
		        }
		      };

		      scanOverlayInstance = { show, hide, update, overlay };
		      return scanOverlayInstance;
		    }

		    function showScanOverlay() {
		      const overlay = scanOverlayInstance || ensureScanOverlay();
		      if (!overlay) return null;
		      void ensureScanProgressListener();
		      activeScanId = generateScanId();
		      scanProgressState = { dirs: 0, files: 0, matched: 0, path: '' };
		      overlay.update();
		      overlay.show();
		      return activeScanId;
		    }

		    function hideScanOverlay() {
		      if (!scanOverlayInstance) return;
		      scanOverlayInstance.hide();
		      activeScanId = null;
		      scanProgressState = { dirs: 0, files: 0, matched: 0, path: '' };
		    }

		    function updateScanOverlayLanguage() {
		      if (!scanOverlayInstance || !activeScanId) return;
		      scanOverlayInstance.update();
		    }

		    function handleScanProgressEvent(payload) {
		      if (!scanOverlayInstance || !activeScanId) return;
		      if (!payload || typeof payload !== 'object') return;
		      const scanId = payload.scanId ? String(payload.scanId) : null;
		      if (scanId && scanId !== activeScanId) return;

		      const dirs = Number(payload.scannedDirs);
		      const files = Number(payload.scannedFiles);
		      const matched = Number(payload.matchedFiles);
		      const path = payload.currentPath ? String(payload.currentPath) : '';

		      if (Number.isFinite(dirs) && dirs >= 0) scanProgressState.dirs = Math.max(scanProgressState.dirs, dirs);
		      if (Number.isFinite(files) && files >= 0) scanProgressState.files = Math.max(scanProgressState.files, files);
		      if (Number.isFinite(matched) && matched >= 0) scanProgressState.matched = Math.max(scanProgressState.matched, matched);
		      if (path) scanProgressState.path = path;

		      scanOverlayInstance.update();
		    }

		    async function ensureScanProgressListener() {
		      if (!tauriEvent || typeof tauriEvent.listen !== 'function') return;
		      if (scanProgressUnlisten) return;
		      try {
		        scanProgressUnlisten = await tauriEvent.listen('rustreader_scan_progress', (event) => {
		          handleScanProgressEvent(event?.payload);
		        });
		      } catch (error) {
		        console.error('scan progress listen failed', error);
		      }
		    }

		    void ensureScanProgressListener();

		    function ensureAboutModal() {
		      if (aboutModalInstance || !document?.body) return aboutModalInstance;
		
		      const overlay = document.createElement('div');
	      overlay.className = 'xspreadsheet-size-modal';
	      overlay.setAttribute('aria-hidden', 'true');
	      overlay.innerHTML = `
	        <div class="xspreadsheet-size-modal__dialog" role="dialog" aria-modal="true" aria-labelledby="aboutModalTitle" style="width: min(520px, 100%);">
	          <button type="button" class="xspreadsheet-size-modal__close" aria-label="${escapeHtml(t('close'))}" title="${escapeHtml(t('close'))}" data-about-close>
	            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
	              <line x1="6" y1="6" x2="18" y2="18"></line>
	              <line x1="6" y1="18" x2="18" y2="6"></line>
	            </svg>
	          </button>
	          <div class="xspreadsheet-size-modal__title" id="aboutModalTitle" data-about-title>${escapeHtml(t('aboutTitle'))}</div>
	          <div class="flex-col gap-2 text-sm">
	            <div class="flex-col gap-1">
	              <div class="text-muted" data-about-label="name">${escapeHtml(t('softwareName'))}</div>
	              <div id="aboutAppName" style="font-weight: 600; word-break: break-word;"></div>
	            </div>
	            <div class="flex-col gap-1">
	              <div class="text-muted" data-about-label="author">${escapeHtml(t('author'))}</div>
	              <div id="aboutAuthor" style="word-break: break-word;"></div>
	            </div>
	            <div class="flex-col gap-1">
	              <div class="text-muted" data-about-label="github">${escapeHtml(t('githubUrl'))}</div>
	              <a id="aboutGithubLink" href="#" target="_blank" rel="noopener noreferrer" style="word-break: break-all;"></a>
	            </div>
	          </div>
	          <div class="xspreadsheet-size-modal__actions">
	            <button type="button" class="btn btn--primary btn-sm" data-about-ok>${escapeHtml(t('close'))}</button>
	          </div>
	        </div>
	      `;
	      document.body.appendChild(overlay);

	      const titleEl = overlay.querySelector('[data-about-title]');
	      const nameLabelEl = overlay.querySelector('[data-about-label="name"]');
	      const authorLabelEl = overlay.querySelector('[data-about-label="author"]');
	      const githubLabelEl = overlay.querySelector('[data-about-label="github"]');
	      const appNameEl = overlay.querySelector('#aboutAppName');
	      const authorEl = overlay.querySelector('#aboutAuthor');
	      const githubLinkEl = overlay.querySelector('#aboutGithubLink');
	      const closeBtn = overlay.querySelector('[data-about-close]');
	      const okBtn = overlay.querySelector('[data-about-ok]');

	      let lastFocusedElement = null;

	      const updateLanguage = () => {
	        if (titleEl) titleEl.textContent = t('aboutTitle');
	        if (nameLabelEl) nameLabelEl.textContent = t('softwareName');
	        if (authorLabelEl) authorLabelEl.textContent = t('author');
	        if (githubLabelEl) githubLabelEl.textContent = t('githubUrl');
	        if (closeBtn) {
	          closeBtn.setAttribute('aria-label', t('close'));
	          closeBtn.title = t('close');
	        }
	        if (okBtn) okBtn.textContent = t('close');
	        if (appNameEl) appNameEl.textContent = document.title || APP_PREFIX;
	        if (authorEl) authorEl.textContent = APP_AUTHOR;
	        if (githubLinkEl) {
	          githubLinkEl.textContent = APP_GITHUB_URL;
	          githubLinkEl.href = APP_GITHUB_URL;
	        }
	      };

	      const hide = () => {
	        overlay.classList.remove('is-open');
	        overlay.setAttribute('aria-hidden', 'true');
	        if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
	          lastFocusedElement.focus();
	        }
	      };

	      const show = () => {
	        lastFocusedElement = document.activeElement;
	        overlay.classList.add('is-open');
	        overlay.setAttribute('aria-hidden', 'false');
	        updateLanguage();
	        requestAnimationFrame(() => {
	          if (okBtn && typeof okBtn.focus === 'function') okBtn.focus();
	          else if (closeBtn && typeof closeBtn.focus === 'function') closeBtn.focus();
	        });
	      };

	      closeBtn?.addEventListener('click', hide);
	      okBtn?.addEventListener('click', hide);
	      overlay.addEventListener('click', (evt) => {
	        if (evt.target === overlay) hide();
	      });
	      overlay.addEventListener('keydown', (evt) => {
	        if (evt.key === 'Escape') {
	          evt.preventDefault();
	          hide();
	        }
	      });

	      aboutModalInstance = {
	        open: show,
	        close: hide,
	        updateLanguage,
	      };
	      return aboutModalInstance;
	    }

	    function updateAboutModalLanguage() {
	      if (!aboutModalInstance) return;
	      if (typeof aboutModalInstance.updateLanguage === 'function') aboutModalInstance.updateLanguage();
	    }

	    function openAboutModal() {
	      const modal = aboutModalInstance || ensureAboutModal();
	      if (!modal || typeof modal.open !== 'function') return;
	      modal.open();
	    }

	    function rerenderForLanguageChange() {
	      updateCurrentSourceLabel();
	      renderCategoryFilters();
	      renderTree();

      if (filteredFiles.length > 0) {
        setCurrentFile(currentIndex);
        return;
      }

      if (!hasUserSelection) {
        if (previewTitleEl) previewTitleEl.textContent = t('selectFolder');
        if (previewSubtitleEl) previewSubtitleEl.textContent = t('selectFolderHint');
        showPreviewPlaceholder(t('selectFolderHint'));
      } else {
        showPreviewPlaceholder(t('emptyNoPreviewable'));
      }
    }

	    if (langToggleBtn) {
	      langToggleBtn.addEventListener('click', () => {
	        const nextLang = currentLang === 'zh' ? 'en' : 'zh';
	        setLanguage(nextLang, true);
	        rerenderForLanguageChange();
	      });
	    }
	    if (aboutBtn) {
	      aboutBtn.addEventListener('click', () => {
	        openAboutModal();
	      });
	    }
	    setLanguage(currentLang, false);

    // Updated Class Names for Icons (no 'file-' prefix as per CSS)
    const FILE_TYPE_ICON_MAP = {
      images: { className: 'icon-images', paths: [{ d: 'm2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z' }] },
      video: { className: 'icon-video', paths: [{ d: 'M21 7l-7 5 7 5V7Z' }, { d: 'M3 5h11a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2Z' }] },
      audio: { className: 'icon-audio', paths: [{ d: 'M11 5 6 9H2v6h4l5 4V5Z' }, { d: 'M19 9a4 4 0 0 1 0 6' }, { d: 'M22 7a8 8 0 0 1 0 10' }] },
      markdown: { className: 'icon-markdown', paths: [{ d: 'M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5' }] },
      drawio: { className: 'icon-default', paths: [{ d: 'M4 7h16v10H4z' }, { d: 'M4 7 12 4l8 3' }] }, 
      pdf: { className: 'icon-pdf', paths: [{ d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m6.75 12H9m1.5-12H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z' }] },
      word: { className: 'icon-word', paths: [{ d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z' }] },
      excel: { className: 'icon-excel', paths: [{ d: 'M3.375 19.5h17.25m-17.25 0a1.125 1.125 0 0 1-1.125-1.125M3.375 19.5h7.5' }] }, 
      text: { className: 'icon-default', paths: [{ d: 'M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25H12' }] },
      slides: { className: 'icon-slides', paths: [{ d: 'M3.75 3v11.25A2.25 2.25 0 0 0 6 16.5h2.25' }] }, 
      default: { className: 'icon-generic', paths: [{ d: 'M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z' }] },
    };
    
    const FOLDER_ICON = {
      paths: [{ d: 'M3.75 9.776c.112-.017.227-.026.344-.026h15.812c.117 0 .232.009.344.026m-16.5 0a2.25 2.25 0 0 0-1.883 2.542l.857 6a2.25 2.25 0 0 0 2.227 1.932H19.05a2.25 2.25 0 0 0 2.227-1.932l.857-6a2.25 2.25 0 0 0-1.883-2.542m-16.5 0V6A2.25 2.25 0 0 1 6 3.75h3.879a1.5 1.5 0 0 1 1.06.44l2.122 2.12a1.5 1.5 0 0 0 1.06.44H18A2.25 2.25 0 0 1 20.25 9v.776' }]
    };

    const scriptLoadingCache = new Map();
    function loadExternalScript(src) {
      if (!src) return Promise.reject(new Error(t('missingScriptSrc')));
      if (scriptLoadingCache.has(src)) return scriptLoadingCache.get(src);
      const promise = new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error(t('scriptLoadFailed', { src })));
        document.head.appendChild(script);
      });
      scriptLoadingCache.set(src, promise);
      return promise;
    }

    const PDFJS_SRC = 'assets/pdf.min.js';
    const PDFJS_WORKER_SRC = 'assets/pdf.worker.min.js';
    let pdfjsReadyPromise = null;
    async function ensurePdfJs() {
      if (window.pdfjsLib) {
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_SRC;
        return window.pdfjsLib;
      }
      if (!pdfjsReadyPromise) {
        pdfjsReadyPromise = loadExternalScript(PDFJS_SRC).then(() => {
          if (!window.pdfjsLib) throw new Error(t('pdfJsLoadFailed'));
          window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_SRC;
          return window.pdfjsLib;
        });
      }
      return pdfjsReadyPromise;
    }

    const NAME_COLLATOR = (typeof Intl !== 'undefined' && typeof Intl.Collator === 'function')
      ? new Intl.Collator('zh-CN', { numeric: true, sensitivity: 'base' })
      : null;

    function getFileName(path) {
      if (!path) return '';
      const parts = path.split('/');
      return parts[parts.length - 1] || path;
    }
	    function escapeHtml(text) {
	      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
	    }

	    const LATEX_DELIMITERS = [
	      { left: '$$', right: '$$', display: true },
	      { left: '\\[', right: '\\]', display: true },
	      { left: '$', right: '$', display: false },
	      { left: '\\(', right: '\\)', display: false },
	    ];

	    function renderLatexInContainer(container) {
	      if (!container) return;
	      if (typeof window.katex !== 'object') return;
	      if (typeof window.renderMathInElement !== 'function') return;
	      try {
	        window.renderMathInElement(container, {
	          delimiters: LATEX_DELIMITERS,
	          throwOnError: false,
	          strict: 'ignore',
	        });
	      } catch {}
	    }
    function getCategoryLabel(type) {
      if (type === 'all') return t('all');
      const categoryConfig = getCategoryConfig();
      return categoryConfig[type]?.label || type;
    }
    function compareNames(a, b) {
      if (NAME_COLLATOR) return NAME_COLLATOR.compare(a || '', b || '');
      return (a || '').localeCompare(b || '');
    }

    function renderCategoryFilters() {
      if (!categoryFiltersEl) return;
      if (typeof disposeCategoryMoreMenu === 'function') {
        disposeCategoryMoreMenu();
        disposeCategoryMoreMenu = null;
      }
      const totals = { all: 0 };
      fileGroups.forEach(g => {
        Object.entries(g?.categories || {}).forEach(([t, f]) => {
          totals[t] = (totals[t] || 0) + f.length;
          totals.all += f.length;
        });
      });
      
      const primaryTypes = ['all', 'markdown', 'marpit', 'pdf', 'word', 'slides'];
      const moreTypes = CATEGORY_ORDER.filter(t => !primaryTypes.includes(t));
      const activeInPrimary = primaryTypes.includes(currentCategory);
      const activeInMore = !activeInPrimary;
      categoryFiltersEl.innerHTML = '';

      const applyCategoryFilter = (type) => {
        if (currentCategory === type) return;
        currentCategory = type;
        currentIndex = 0;
        renderCategoryFilters();
        renderTree();
        if (filteredFiles.length) setCurrentFile(0);
        else showPreviewPlaceholder(t('filterNoMatch'));
        
        if (window.innerWidth < 768) {
          document.getElementById('categoryFilters').classList.remove('is-open');
        }
      };

      const createChipButton = (type) => {
        const count = type === 'all' ? totals.all : (totals[type] || 0);
        const button = document.createElement('button');
        button.className = 'nav__item';
        if (type === currentCategory) button.classList.add('nav__item--active');
        button.textContent = `${getCategoryLabel(type)} (${count})`;
        if (type !== 'all' && !count) {
          button.disabled = true;
          return button;
        }
        button.addEventListener('click', () => applyCategoryFilter(type));
        return button;
      };

      primaryTypes.forEach((type) => {
        categoryFiltersEl.appendChild(createChipButton(type));
      });

      const moreWrap = document.createElement('div');
      moreWrap.className = 'nav__more';
      const moreBtn = document.createElement('button');
      moreBtn.type = 'button';
      moreBtn.className = 'nav__item nav__item--icon';
      if (activeInMore) moreBtn.classList.add('nav__item--active');
      moreBtn.title = t('more');
      moreBtn.setAttribute('aria-label', t('moreFilters'));
      moreBtn.setAttribute('aria-haspopup', 'menu');
      moreBtn.setAttribute('aria-expanded', 'false');
      moreBtn.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
          <circle cx="12" cy="12" r="1"></circle>
          <circle cx="19" cy="12" r="1"></circle>
          <circle cx="5" cy="12" r="1"></circle>
        </svg>`;

      const dropdown = document.createElement('div');
      dropdown.className = 'nav__dropdown';
      dropdown.setAttribute('role', 'menu');
      dropdown.setAttribute('aria-label', t('moreFilters'));

      moreTypes.forEach((type) => {
        const count = type === 'all' ? totals.all : (totals[type] || 0);
        const item = document.createElement('button');
        item.type = 'button';
        item.className = 'nav__dropdown-item';
        if (type === currentCategory) item.classList.add('nav__dropdown-item--active');
        item.innerHTML = `
          <span class="nav__dropdown-label">${escapeHtml(getCategoryLabel(type))}</span>
          <span class="nav__dropdown-count">${count}</span>
        `;
        if (type !== 'all' && !count) {
          item.disabled = true;
        } else {
          item.addEventListener('click', () => {
            closeMenu();
            applyCategoryFilter(type);
          });
        }
        dropdown.appendChild(item);
      });

      const closeMenu = () => {
        dropdown.classList.remove('is-open');
        moreBtn.setAttribute('aria-expanded', 'false');
      };
      const toggleMenu = () => {
        const open = dropdown.classList.toggle('is-open');
        moreBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
      };

      moreBtn.addEventListener('click', (event) => {
        event.preventDefault();
        event.stopPropagation();
        toggleMenu();
      });

      const onDocClick = (event) => {
        if (!moreWrap.contains(event.target)) closeMenu();
      };
      const onDocKeydown = (event) => {
        if (event.key === 'Escape') closeMenu();
      };
      document.addEventListener('click', onDocClick);
      document.addEventListener('keydown', onDocKeydown);
      disposeCategoryMoreMenu = () => {
        document.removeEventListener('click', onDocClick);
        document.removeEventListener('keydown', onDocKeydown);
      };

      moreWrap.appendChild(moreBtn);
      moreWrap.appendChild(dropdown);
      categoryFiltersEl.appendChild(moreWrap);
    }

	    function createSvgIcon(iconConfig) {
	      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 24 24');
      svg.setAttribute('fill', 'none');
      svg.setAttribute('stroke', 'currentColor');
      svg.setAttribute('stroke-width', 1.5);
      (iconConfig.paths || []).forEach(p => {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', p.d);
        svg.appendChild(path);
      });
	      return svg;
	    }

	    function computeCurrentSourceLabel() {
	      if (currentSourceKind === 'local') {
	        const label = String(currentSourceName || '').trim();
	        return label ? `${t('localPrefix')}${label}` : t('localFolder');
	      }
	      if (currentSourceKind === 'none') {
	        return t('noFolderSelected');
	      }
	      return String(currentSourceName || '').trim() || t('currentDirectory');
	    }

	    function updateCurrentSourceLabel() {
	      currentSourceLabel = computeCurrentSourceLabel();
	    }

	    function getTreeRootLabel() {
	      if (currentSourceKind === 'local') {
	        return String(currentSourceName || '').trim() || t('openedDirectory');
	      }
	      if (currentSourceKind === 'none') {
	        return t('currentDirectory');
	      }
	      return String(currentSourceName || '').trim() || t('currentDirectory');
	    }

	    function createDirectoryNode(node, level = 0) {
	      if (!node || !node.totalCount) return null;
	      const details = document.createElement('details');
      details.className = 'tree__group';
      details.open = level < 2;

      const summary = document.createElement('summary');
      summary.className = 'tree__summary';

      const titleSpan = document.createElement('span');
      titleSpan.style.display = 'flex';
      titleSpan.style.alignItems = 'center';
      titleSpan.style.gap = '0.5rem';
      
      const icon = document.createElement('span');
      icon.className = 'tree__icon icon-folder';
      icon.style.color = '#F59E0B';
      icon.appendChild(createSvgIcon(FOLDER_ICON));
      titleSpan.appendChild(icon);
	      
	      const text = document.createElement('span');
	      text.textContent = node.isRoot ? getTreeRootLabel() : node.name;
	      titleSpan.appendChild(text);
      
      const count = document.createElement('span');
      count.className = 'tree__count';
      count.textContent = node.totalCount;

      summary.appendChild(titleSpan);
      summary.appendChild(count);
      details.appendChild(summary);

      const childrenWrapper = document.createElement('div');
      childrenWrapper.className = 'tree__children';
      if (node.isRoot) childrenWrapper.classList.add('tree__children--root');

      const sortedChildren = Array.from(node.children.values())
        .filter(c => c.totalCount)
        .sort((a, b) => compareNames(a.name, b.name));
        
      sortedChildren.forEach(child => {
        const childNode = createDirectoryNode(child, level + 1);
        if (childNode) childrenWrapper.appendChild(childNode);
      });

      if (node.files.length) {
        const fileContent = document.createElement('div');
        fileContent.className = 'tree__content';
        const sortedFiles = [...node.files].sort((a, b) => compareNames(getFileName(a.path), getFileName(b.path)));
        sortedFiles.forEach(entry => {
           fileContent.appendChild(createFileItem(entry));
        });
        childrenWrapper.appendChild(fileContent);
      }

      details.appendChild(childrenWrapper);
      return details;
    }

    function createFileItem(entry) {
      const entryIndex = filteredFiles.length;
      filteredFiles.push(entry);
      const item = document.createElement('button');
      item.className = 'tree__item';
      item.dataset.index = entryIndex;
      if (entryIndex === currentIndex) item.classList.add('tree__item--active');

      const iconConfig = FILE_TYPE_ICON_MAP[entry.type] || FILE_TYPE_ICON_MAP.default;
      const iconSpan = document.createElement('span');
      iconSpan.className = `tree__icon ${iconConfig.className}`;
      iconSpan.appendChild(createSvgIcon(iconConfig));
      
      const textSpan = document.createElement('span');
      textSpan.className = 'tree__text';
      textSpan.textContent = getFileName(entry.path);
      textSpan.title = getFileName(entry.path);

      item.appendChild(iconSpan);
      item.appendChild(textSpan);
      
      item.addEventListener('click', () => setCurrentFile(entryIndex));
      return item;
    }

    function buildDirectoryTree(entries) {
      const createNode = (name, path, isRoot = false) => ({
        name, path, children: new Map(), files: [], totalCount: 0, isRoot
      });
      const root = createNode('Root', '.', true);
      entries.forEach(entry => {
         const normalized = (entry.path || '').replace(/^\.\/+/, '');
         const segments = normalized ? normalized.split('/').filter(Boolean) : [];
         if (!segments.length) { root.files.push(entry); return; }
         
         let current = root;
         const dirs = segments.slice(0, segments.length - 1);
         dirs.forEach(dir => {
            if (!current.children.has(dir)) {
              current.children.set(dir, createNode(dir, current.path === '.' ? dir : `${current.path}/${dir}`));
            }
            current = current.children.get(dir);
         });
         current.files.push(entry);
      });
      
      const compute = (node) => {
        let total = node.files.length;
        node.children.forEach(c => total += compute(c));
        node.totalCount = total;
        return total;
      };
      compute(root);
      return root;
    }

    function renderTree() {
      if (!treeContainer) return;
      treeContainer.innerHTML = '';
      filteredFiles = [];
      const search = treeSearchTerm.trim().toLowerCase();
      
      const allEntries = [];
      fileGroups.forEach((g, idx) => {
        Object.entries(g?.categories || {}).forEach(([type, files]) => {
           files.forEach(path => {
             if (currentCategory !== 'all' && currentCategory !== type) return;
             if (search) {
                if (!path.toLowerCase().includes(search)) return;
             }
             allEntries.push({ path, type, groupIndex: idx });
           });
        });
      });
      
		      if (!allEntries.length) {
		        const hasSelection = hasUserSelection;
		        const totalPreviewableCount = fileGroups.reduce((sum, group) => {
		          const categories = group?.categories || {};
		          return sum + Object.values(categories).reduce((sub, files) => sub + (files?.length || 0), 0);
		        }, 0);
		        const hasAnyPreviewableFiles = totalPreviewableCount > 0;
		        treeContainer.innerHTML = '';
		        const emptyWrap = document.createElement('div');
		        emptyWrap.style.padding = '1rem';
		        emptyWrap.style.color = 'var(--color-text-muted)';
		        emptyWrap.style.textAlign = 'center';
		        emptyWrap.style.display = 'flex';
		        emptyWrap.style.flexDirection = 'column';
		        emptyWrap.style.gap = '0.75rem';
		        emptyWrap.style.alignItems = 'center';
		        emptyWrap.style.justifyContent = 'center';

			        const emptyText = document.createElement('div');
			        let emptyMessage = t('emptyNoMatch');
			        if (!hasSelection) {
			          emptyMessage = t('emptyClickOpenFolder');
			        } else if (!hasAnyPreviewableFiles) {
			          emptyMessage = t('emptyNoPreviewable');
			        }
			        emptyText.textContent = emptyMessage;
			        emptyWrap.appendChild(emptyText);

			        if (!hasSelection || !hasAnyPreviewableFiles) {
			          const openBtn = document.createElement('button');
			          openBtn.type = 'button';
			          openBtn.className = 'btn btn--primary btn-sm';
			          openBtn.textContent = t('openFolder');
		          openBtn.addEventListener('click', () => {
		            void requestOpenFolder();
		          });
		          emptyWrap.appendChild(openBtn);
		        }

			        treeContainer.appendChild(emptyWrap);
			        if (treeMetaEl) {
			          const prefix = currentSourceLabel ? `${currentSourceLabel} · ` : '';
			          if (!hasSelection) treeMetaEl.textContent = currentSourceLabel || t('noFolderSelected');
			          else if (!hasAnyPreviewableFiles) treeMetaEl.textContent = `${prefix}${t('treeMetaNoPreviewable')}`;
			          else treeMetaEl.textContent = `${prefix}${t('treeMetaNoMatch')}`;
			        }
			        return;
			      }
      
      const treeData = buildDirectoryTree(allEntries);
      const rootNode = createDirectoryNode(treeData, 0);
      if (rootNode) treeContainer.appendChild(rootNode);
      
      if (currentIndex >= filteredFiles.length) currentIndex = 0;
      updateTreeSelection();
	      if (treeMetaEl) {
	        const prefix = currentSourceLabel ? `${currentSourceLabel} · ` : '';
	        treeMetaEl.textContent = `${prefix}${t('treeMetaMatchCount', { count: filteredFiles.length })}`;
	      }
	    }

    function updateTreeSelection() {
      document.querySelectorAll('.tree__item').forEach(item => {
         const idx = Number(item.dataset.index);
         if (idx === currentIndex) {
           item.classList.add('tree__item--active');
           let parent = item.closest('details');
           while(parent) {
             parent.open = true;
             parent = parent.parentElement ? parent.parentElement.closest('details') : null;
           }
           item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
         } else {
           item.classList.remove('tree__item--active');
         }
      });
    }

    function setCurrentFile(index) {
      if (!filteredFiles.length) return;
      currentIndex = (index + filteredFiles.length) % filteredFiles.length;
      updateTreeSelection();
	      const entry = filteredFiles[currentIndex];
	      if (entry) {
	         if (previewTitleEl) previewTitleEl.textContent = getFileName(entry.path);
	         if (previewSubtitleEl) {
	           const parts = [];
	           if (currentSourceLabel) parts.push(currentSourceLabel);
	           parts.push(getCategoryLabel(entry.type), entry.path);
	           previewSubtitleEl.textContent = parts.join(' · ');
	         }
	         
	         if (entry.type === 'images') showImagePreview(entry.path);
	         else showDocumentPreview(entry.path, entry.type);
	      }
	    }
    
    function slugify(text) {
      return text
        .toLowerCase()
        .trim()
        .replace(/[\s]+/g, '-')
        .replace(/[^\w\-一-龥]+/g, '')
        .replace(/--+/g, '-');
    }

    function buildMarkdownTocData(container) {
      if (!container) return [];
      const headings = Array.from(container.querySelectorAll('h1, h2, h3, h4, h5, h6'));
      if (!headings.length) return [];
      
      const slugCounts = new Map();
      const entries = [];
      
      headings.forEach((heading) => {
        const text = heading.textContent?.trim() || '';
        if (!text) return;
        const base = slugify(text) || `section-${entries.length + 1}`;
        const count = slugCounts.get(base) || 0;
        slugCounts.set(base, count + 1);
        const slug = count ? `${base}-${count}` : base;
        heading.id = slug;
        const level = Number(heading.tagName.replace('H', ''));
        entries.push({ slug, text, level });
      });
      return entries;
    }

    async function previewMarkdown(path) {
       const text = await fetchText(path);
       const html = window.marked ? window.marked.parse(text) : `<pre>${escapeHtml(text)}</pre>`;
       
       const parser = new DOMParser();
       const parsed = parser.parseFromString(html, 'text/html');
       
       const tocEntries = buildMarkdownTocData(parsed.body);
       const bodyHtml = parsed.body.innerHTML;

       let sidebarHtml = '';
       let toggleBtnHtml = '';
       
       if (tocEntries.length > 0) {
         const listItems = tocEntries.map(entry => 
            `<a href="#${entry.slug}" class="markdown-toc-item toc-level-${entry.level}" title="${escapeHtml(entry.text)}">${escapeHtml(entry.text)}</a>`
         ).join('');
         
         sidebarHtml = `
           <aside id="mdSidebar" class="markdown-sidebar collapsed"> <!-- Add 'collapsed' class -->
             <div class="markdown-sidebar__header">
               <span>${escapeHtml(t('toc'))}</span>
               <button id="closeMdSidebarBtn" class="btn btn--ghost btn-sm" style="padding: 4px;">✕</button>
             </div>
             <div class="markdown-sidebar__search">
               <input type="text" id="mdTocSearch" class="input" placeholder="${escapeHtml(t('searchToc'))}" style="padding: 0.4rem 0.6rem; font-size: 0.85rem;">
             </div>
             <nav id="mdTocList" class="markdown-toc-list">
               ${listItems}
             </nav>
           </aside>
         `;
         
         toggleBtnHtml = `
           <button id="mdSidebarToggle" class="markdown-floating-toggle" title="${escapeHtml(t('showToc'))}"> <!-- Remove 'hidden' class -->
             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
           </button>
         `;
       }

	       docPreviewEl.innerHTML = `
	        <div class="markdown-wrapper">
	          ${sidebarHtml}
	          ${toggleBtnHtml}
	          <div class="markdown-content">
	            <article class="markdown-body">${bodyHtml}</article>
	          </div>
	        </div>
	       `;

	       renderLatexInContainer(docPreviewEl.querySelector('.markdown-body'));
	       
	       if (tocEntries.length > 0) {
	           const sidebar = document.getElementById('mdSidebar');
	           const toggleBtn = document.getElementById('mdSidebarToggle');
	           const closeBtn = document.getElementById('closeMdSidebarBtn');
           const searchInput = document.getElementById('mdTocSearch');
           
           const toggleSidebar = () => {
               sidebar.classList.toggle('collapsed');
               toggleBtn.classList.toggle('hidden');
           };
           
           if (toggleBtn) toggleBtn.addEventListener('click', toggleSidebar);
           if (closeBtn) closeBtn.addEventListener('click', toggleSidebar);
           
           if (searchInput) {
               searchInput.addEventListener('input', (e) => {
                   const val = e.target.value.toLowerCase();
                   const items = document.querySelectorAll('.markdown-toc-item');
                   items.forEach(item => {
                       const text = item.textContent.toLowerCase();
                       item.style.display = text.includes(val) ? 'block' : 'none';
                   });
               });
           }
       }
    }

    function showImagePreview(path) {
       cleanupDrawioPanHandlers();
       cleanupMarpitNavigation();
       cleanupPdfViewer();
       cleanupMediaPreview();
       imagePreviewWrapper.classList.remove('hidden');
       docPreviewEl.classList.add('hidden');

	       singleImage.src = resolveResourceUrl(path);
	       resetZoom();
	    }

    async function showDocumentPreview(path, type) {
       imagePreviewWrapper.classList.add('hidden');
       docPreviewEl.classList.remove('hidden');

       cleanupDrawioPanHandlers();
       cleanupPptxViewer();
       cleanupMarpitNavigation();
       cleanupPdfViewer();
       cleanupMediaPreview();
       cleanupWordToc();
       cleanupExcelPreview();

       showDocStatus(t('loading'));
       try {
          if (type === 'markdown') await previewMarkdown(path);
          else if (type === 'text') await previewText(path);
          else if (type === 'video') await previewVideo(path);
          else if (type === 'audio') await previewAudio(path);
          else if (type === 'mindmap') await previewMindmap(path);
          else if (type === 'drawio') await previewDrawio(path);
          else if (type === 'marpit') await previewMarpit(path);
          else if (type === 'pdf') await previewPdf(path);
          else if (type === 'word') await previewWord(path);
          else if (type === 'excel') await previewExcel(path);
          else if (type === 'slides') await previewSlides(path);
          else showDocStatus(t('unsupportedPreview'));
       } catch (e) {
          showDocStatus(t('loadFailed', { message: e?.message || String(e) }));
       }
    }

    function showDocStatus(msg) {
       docPreviewEl.innerHTML = `<div style="height:100%; display:flex; align-items:center; justify-content:center; color:var(--color-text-muted);">${msg}</div>`;
    }
    function setExcelPreviewState(isActive) {
      if (!docPreviewEl) return;
      const previewContent = docPreviewEl.closest('.preview__content');
      docPreviewEl.classList.toggle('excel-preview-active', !!isActive);
      if (previewContent) {
        previewContent.classList.toggle('excel-preview-active', !!isActive);
      }
    }
    function cleanupExcelPreview() {
      setExcelPreviewState(false);
    }

    const ROW_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5V19"/><polyline points="8 9 12 5 16 9"/><polyline points="8 15 12 19 16 15"/><rect x="5" y="9" width="14" height="6" rx="1.5"/></svg>`;
    const COL_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12H19"/><polyline points="9 8 5 12 9 16"/><polyline points="15 8 19 12 15 16"/><rect x="9" y="5" width="6" height="14" rx="1.5"/></svg>`;
    const TEXT_COLOR_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20H20"/><path d="M12 4L8 16H10.5L11.4 13H16.6L17.5 16H20L16 4H12Z"/></svg>`;
    const FILL_COLOR_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4L20 8L12 16L4 8L8 4H16Z"/><path d="M12 16V20A2 2 0 0 0 14 22H18A2 2 0 0 0 20 20V16"/></svg>`;
    const AUTO_ROW_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 5H20"/><path d="M4 19H20"/><path d="M12 9V15"/><polyline points="9 11 12 8 15 11"/><polyline points="9 13 12 16 15 13"/></svg>`;
    const AUTO_COL_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M5 4V20"/><path d="M19 4V20"/><path d="M9 12H15"/><polyline points="11 9 8 12 11 15"/><polyline points="13 9 16 12 13 15"/></svg>`;
    const AUTO_ALL_ICON_SVG = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2"/><path d="M9 4V8"/><path d="M15 4V8"/><path d="M4 9H8"/><path d="M4 15H8"/><path d="M16 20V16"/><path d="M20 9H16"/><polyline points="9 12 12 9 15 12"/><polyline points="9 12 12 15 15 12"/></svg>`;
    const SIZE_MODAL_DEFAULTS = { row: 28, col: 100 };
    const COLOR_DEFAULTS = { text: '#1f2937', fill: '#ffffff' };
    const AUTOFIT_SETTINGS = {
      minColWidth: 60,
      maxColWidth: 720,
      minRowHeight: 24,
      maxRowHeight: 420,
      padding: 18,
      lineHeight: 18,
      defaultFont: 'normal 12px Arial',
    };
    let spreadsheetSizeModalInstance = null;
    let spreadsheetMeasureCtx = null;

    function applyUniformSize(xInstance, kind, value) {
      const sheetData = xInstance?.sheet?.data;
      if (!sheetData) return;
      if (kind === 'row') {
        const rows = sheetData.rows;
        if (!rows || typeof rows.len !== 'number') return;
        for (let i = 0; i < rows.len; i += 1) {
          rows.setHeight(i, value);
        }
      } else {
        const cols = sheetData.cols;
        if (!cols || typeof cols.len !== 'number') return;
        for (let i = 0; i < cols.len; i += 1) {
          cols.setWidth(i, value);
        }
      }
      if (typeof xInstance.reRender === 'function') {
        xInstance.reRender();
      }
    }

    function ensureMeasureContext() {
      if (spreadsheetMeasureCtx) return spreadsheetMeasureCtx;
      const canvas = document.createElement('canvas');
      spreadsheetMeasureCtx = canvas.getContext('2d');
      if (spreadsheetMeasureCtx) spreadsheetMeasureCtx.font = AUTOFIT_SETTINGS.defaultFont;
      return spreadsheetMeasureCtx;
    }

    function measureTextWidth(text) {
      if (!text) return 0;
      const ctx = ensureMeasureContext();
      if (!ctx) return text.length * 8;
      if (ctx.font !== AUTOFIT_SETTINGS.defaultFont) {
        ctx.font = AUTOFIT_SETTINGS.defaultFont;
      }
      const metrics = ctx.measureText(text);
      return metrics?.width || text.length * 8;
    }

    function measureLongestLineWidth(text) {
      if (!text) return 0;
      return text
        .split(/\r?\n/)
        .map((line) => measureTextWidth(line))
        .reduce((max, width) => (width > max ? width : max), 0);
    }

    function getCellDisplayText(cell) {
      if (!cell) return '';
      if (typeof cell.text === 'string') return cell.text;
      if (cell.value === null || cell.value === undefined) return '';
      if (typeof cell.value === 'object') {
        if (typeof cell.value.text === 'string') return cell.value.text;
        if (cell.value.v !== undefined) return String(cell.value.v);
      }
      return String(cell.value);
    }

    function getActiveSheetStructure(xInstance) {
      if (!xInstance || typeof xInstance.getData !== 'function') return null;
      const workbook = xInstance.getData();
      if (!Array.isArray(workbook) || !workbook.length) return null;
      const activeName = xInstance.sheet?.data?.name;
      if (activeName) {
        const match = workbook.find((sheet) => sheet.name === activeName);
        if (match) return match;
      }
      return workbook[0];
    }

    function getColumnCount(sheetData, structure) {
      if (typeof sheetData?.cols?.len === 'number') return sheetData.cols.len;
      const structureCols = structure?.cols || {};
      const indices = Object.keys(structureCols).map((key) => Number(key)).filter((num) => !Number.isNaN(num));
      if (indices.length) return Math.max(...indices) + 1;
      return 26;
    }

    function getColumnWidthEstimate(sheetData, structureCols, colIndex) {
      if (typeof sheetData?.cols?.getWidth === 'function') {
        const runtimeWidth = sheetData.cols.getWidth(colIndex);
        if (Number.isFinite(runtimeWidth)) return runtimeWidth;
      }
      const structureWidth = structureCols?.[colIndex]?.width;
      if (Number.isFinite(structureWidth)) return structureWidth;
      return SIZE_MODAL_DEFAULTS.col;
    }

    function autoFitColumns(xInstance, options = {}) {
      const sheetData = xInstance?.sheet?.data;
      const structure = getActiveSheetStructure(xInstance);
      if (!sheetData || !structure) return;
      const rows = structure.rows || {};
      const colCount = getColumnCount(sheetData, structure);
      for (let ci = 0; ci < colCount; ci += 1) {
        let widest = AUTOFIT_SETTINGS.minColWidth;
        Object.values(rows).forEach((row) => {
          const text = getCellDisplayText(row?.cells?.[ci]);
          if (!text) return;
          const width = measureLongestLineWidth(text);
          if (width > widest) widest = width;
        });
        const padded = Math.min(
          AUTOFIT_SETTINGS.maxColWidth,
          Math.max(AUTOFIT_SETTINGS.minColWidth, Math.ceil(widest + AUTOFIT_SETTINGS.padding)),
        );
        if (typeof sheetData.cols?.setWidth === 'function') {
          sheetData.cols.setWidth(ci, padded);
        }
      }
      if (!options.skipRender && typeof xInstance.reRender === 'function') xInstance.reRender();
    }

    function autoFitRows(xInstance, options = {}) {
      const sheetData = xInstance?.sheet?.data;
      const structure = getActiveSheetStructure(xInstance);
      if (!sheetData || !structure) return;
      const rows = structure.rows || {};
      const structureCols = structure.cols || {};
      const defaultRowHeight = Number.isFinite(sheetData?.rows?.height) ? sheetData.rows.height : SIZE_MODAL_DEFAULTS.row;
      Object.entries(rows).forEach(([rowKey, rowValue]) => {
        const rowIndex = Number(rowKey);
        if (Number.isNaN(rowIndex)) return;
        const cells = rowValue?.cells || {};
        let desiredHeight = defaultRowHeight;
        Object.entries(cells).forEach(([colKey, cell]) => {
          const ci = Number(colKey);
          if (Number.isNaN(ci)) return;
          const text = getCellDisplayText(cell);
          if (!text) return;
          const columnWidth = getColumnWidthEstimate(sheetData, structureCols, ci) - AUTOFIT_SETTINGS.padding;
          const usableWidth = Math.max(12, columnWidth);
          const widthBasedLines = Math.max(1, Math.ceil(measureLongestLineWidth(text) / usableWidth));
          const newlineLines = text.split(/\r?\n/).length;
          const totalLines = Math.max(widthBasedLines, newlineLines);
          const cellHeight = Math.max(defaultRowHeight, totalLines * AUTOFIT_SETTINGS.lineHeight);
          if (cellHeight > desiredHeight) desiredHeight = cellHeight;
        });
        if (typeof sheetData.rows?.setHeight === 'function') {
          sheetData.rows.setHeight(
            rowIndex,
            Math.min(AUTOFIT_SETTINGS.maxRowHeight, Math.max(AUTOFIT_SETTINGS.minRowHeight, Math.ceil(desiredHeight))),
          );
        }
      });
      if (!options.skipRender && typeof xInstance.reRender === 'function') xInstance.reRender();
    }

    function autoFitAll(xInstance) {
      autoFitRows(xInstance, { skipRender: true });
      autoFitColumns(xInstance);
    }

    function applyColorAttribute(xInstance, attr, value) {
      if (!value || !xInstance) return;
      const data = xInstance.sheet?.data;
      if (typeof data?.setSelectedCellAttr !== 'function') return;
      data.setSelectedCellAttr(attr, value);
      if (typeof xInstance.sheet?.table?.render === 'function') {
        xInstance.sheet.table.render();
      } else if (typeof xInstance.reRender === 'function') {
        xInstance.reRender();
      }
    }

    function createCustomToolbarButton({ label, title, icon, className, onClick }) {
      const btn = document.createElement('div');
      btn.className = `x-spreadsheet-toolbar-btn xspreadsheet-custom-btn ${className || ''}`.trim();
      btn.title = title;
      btn.setAttribute('role', 'button');
      btn.tabIndex = 0;
      btn.innerHTML = `<span class="custom-toolbar-icon">${icon}</span><span class="custom-toolbar-label">${label}</span>`;
      const handler = (evt) => {
        evt?.preventDefault?.();
        if (typeof onClick === 'function') onClick();
      };
      btn.addEventListener('click', handler);
      btn.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter' || evt.key === ' ') {
          evt.preventDefault();
          handler(evt);
        }
      });
      return btn;
    }

    function createColorToolbarButton({ label, title, icon, defaultColor, onColorChange }) {
      const btn = document.createElement('div');
      btn.className = 'x-spreadsheet-toolbar-btn xspreadsheet-custom-btn xspreadsheet-color-btn';
      btn.title = title;
      btn.tabIndex = 0;
      btn.setAttribute('role', 'button');
      btn.innerHTML = `
        <span class="custom-toolbar-icon">${icon}</span>
        <span class="custom-toolbar-label">${label}</span>
        <span class="xspreadsheet-color-preview" style="--color-value: ${defaultColor}"></span>
      `;
      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = defaultColor;
      colorInput.className = 'xspreadsheet-color-input';
      colorInput.tabIndex = -1;
      btn.appendChild(colorInput);

      const preview = btn.querySelector('.xspreadsheet-color-preview');
      const handleColorChange = (value) => {
        if (!value) return;
        preview?.style.setProperty('--color-value', value);
        if (typeof onColorChange === 'function') onColorChange(value);
      };

      const openPicker = () => {
        try {
          if (typeof colorInput.showPicker === 'function') colorInput.showPicker();
          else colorInput.click();
        } catch (err) {
          colorInput.click();
        }
      };

      btn.addEventListener('click', (evt) => {
        evt.preventDefault();
        openPicker();
      });
      btn.addEventListener('keydown', (evt) => {
        if (evt.key === 'Enter' || evt.key === ' ') {
          evt.preventDefault();
          openPicker();
        }
      });
      colorInput.addEventListener('input', () => handleColorChange(colorInput.value));
      colorInput.addEventListener('change', () => handleColorChange(colorInput.value));
      return btn;
    }

    function ensureSizeModal() {
      if (spreadsheetSizeModalInstance || !document?.body) return spreadsheetSizeModalInstance;
      const overlay = document.createElement('div');
      overlay.className = 'xspreadsheet-size-modal';
      overlay.setAttribute('aria-hidden', 'true');
      overlay.innerHTML = `
        <div class="xspreadsheet-size-modal__dialog" role="dialog" aria-modal="true">
          <button type="button" class="xspreadsheet-size-modal__close" aria-label="${t('close')}" data-size-close>
            <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <line x1="6" y1="6" x2="18" y2="18"></line>
              <line x1="6" y1="18" x2="18" y2="6"></line>
            </svg>
          </button>
          <div class="xspreadsheet-size-modal__title" data-size-title>${t('rowHeightTitle')}</div>
          <label class="xspreadsheet-size-modal__label">
            <span data-size-label>${t('rowHeightPx')}</span>
            <input type="number" min="1" step="1" inputmode="decimal" class="input xspreadsheet-size-modal__input" data-size-input />
          </label>
          <div class="xspreadsheet-size-modal__error" data-size-error></div>
          <div class="xspreadsheet-size-modal__actions">
            <button type="button" class="btn btn--ghost btn-sm" data-size-cancel>${t('cancel')}</button>
            <button type="button" class="btn btn--primary btn-sm" data-size-confirm>${t('confirm')}</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);

      const titleEl = overlay.querySelector('[data-size-title]');
      const labelEl = overlay.querySelector('[data-size-label]');
      const inputEl = overlay.querySelector('[data-size-input]');
      const errorEl = overlay.querySelector('[data-size-error]');
      const confirmBtn = overlay.querySelector('[data-size-confirm]');
      const cancelBtn = overlay.querySelector('[data-size-cancel]');
      const closeBtn = overlay.querySelector('[data-size-close]');

      let confirmHandler = null;
      let lastFocusedElement = null;

      const hide = () => {
        overlay.classList.remove('is-open');
        overlay.setAttribute('aria-hidden', 'true');
        confirmHandler = null;
        if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
          lastFocusedElement.focus();
        }
      };

      const show = ({ kind, defaultValue, onConfirm }) => {
        lastFocusedElement = document.activeElement;
        confirmHandler = onConfirm;
        overlay.classList.add('is-open');
        overlay.setAttribute('aria-hidden', 'false');
        const isRow = kind === 'row';
        titleEl.textContent = isRow ? t('rowHeightTitle') : t('colWidthTitle');
        labelEl.textContent = isRow ? t('rowHeightPx') : t('colWidthPx');
        const fallback = SIZE_MODAL_DEFAULTS[kind] || 10;
        const value = Number.isFinite(defaultValue) ? defaultValue : fallback;
        inputEl.value = value;
        errorEl.textContent = '';
        requestAnimationFrame(() => {
          inputEl.focus();
          inputEl.select();
        });
      };

      const handleConfirm = () => {
        const numeric = Number(inputEl.value);
        if (!Number.isFinite(numeric) || numeric <= 0) {
          errorEl.textContent = t('invalidPositiveNumber');
          inputEl.focus();
          inputEl.select();
          return;
        }
        errorEl.textContent = '';
        if (typeof confirmHandler === 'function') confirmHandler(numeric);
        hide();
      };

      confirmBtn?.addEventListener('click', handleConfirm);
      cancelBtn?.addEventListener('click', hide);
      closeBtn?.addEventListener('click', hide);
      overlay.addEventListener('click', (evt) => {
        if (evt.target === overlay) hide();
      });
      overlay.addEventListener('keydown', (evt) => {
        if (evt.key === 'Escape') {
          evt.preventDefault();
          hide();
        } else if (evt.key === 'Enter' && evt.target === inputEl) {
          evt.preventDefault();
          handleConfirm();
        }
      });

      spreadsheetSizeModalInstance = {
        open: show,
        close: hide,
      };
      return spreadsheetSizeModalInstance;
    }

    function openSizeModal(options) {
      const modal = spreadsheetSizeModalInstance || ensureSizeModal();
      if (!modal) return;
      modal.open(options);
    }

    function customizeSpreadsheetToolbar(xInstance, attempt = 0) {
      if (!docPreviewEl) return;
      const toolbar = docPreviewEl.querySelector('.x-spreadsheet-toolbar');
      if (!toolbar) {
        if (attempt > 8) return;
        setTimeout(() => customizeSpreadsheetToolbar(xInstance, attempt + 1), 50);
        return;
      }

      while (toolbar.firstChild) {
        toolbar.removeChild(toolbar.firstChild);
      }

      const colorGroup = document.createElement('div');
      colorGroup.className = 'x-spreadsheet-toolbar-btns xspreadsheet-custom-color-group';
      const textColorBtn = createColorToolbarButton({
        label: '',
        title: t('setFontColor'),
        icon: TEXT_COLOR_ICON_SVG,
        defaultColor: COLOR_DEFAULTS.text,
        onColorChange: (value) => {
          COLOR_DEFAULTS.text = value;
          applyColorAttribute(xInstance, 'color', value);
        },
      });
      const fillColorBtn = createColorToolbarButton({
        label: '',
        title: t('setFillColor'),
        icon: FILL_COLOR_ICON_SVG,
        defaultColor: COLOR_DEFAULTS.fill,
        onColorChange: (value) => {
          COLOR_DEFAULTS.fill = value;
          applyColorAttribute(xInstance, 'bgcolor', value);
        },
      });
      colorGroup.append(textColorBtn, fillColorBtn);

      const group = document.createElement('div');
      group.className = 'x-spreadsheet-toolbar-btns xspreadsheet-custom-sizing-group';

      const rowBtn = createCustomToolbarButton({
        label: t('rowHeight'),
        title: t('setAllRowHeights'),
        icon: ROW_ICON_SVG,
        className: 'custom-row-height-btn',
        onClick: () => {
          openSizeModal({
            kind: 'row',
            defaultValue: SIZE_MODAL_DEFAULTS.row,
            onConfirm: (value) => {
              SIZE_MODAL_DEFAULTS.row = value;
              applyUniformSize(xInstance, 'row', value);
            },
          });
        },
      });

      const colBtn = createCustomToolbarButton({
        label: t('colWidth'),
        title: t('setAllColWidths'),
        icon: COL_ICON_SVG,
        className: 'custom-col-width-btn',
        onClick: () => {
          openSizeModal({
            kind: 'col',
            defaultValue: SIZE_MODAL_DEFAULTS.col,
            onConfirm: (value) => {
              SIZE_MODAL_DEFAULTS.col = value;
              applyUniformSize(xInstance, 'col', value);
            },
          });
        },
      });

      const autoRowBtn = createCustomToolbarButton({
        label: t('autoRowHeight'),
        title: t('autoRowHeightTitle'),
        icon: AUTO_ROW_ICON_SVG,
        className: 'custom-auto-row-btn',
        onClick: () => autoFitRows(xInstance),
      });

      const autoColBtn = createCustomToolbarButton({
        label: t('autoColWidth'),
        title: t('autoColWidthTitle'),
        icon: AUTO_COL_ICON_SVG,
        className: 'custom-auto-col-btn',
        onClick: () => autoFitColumns(xInstance),
      });

      const autoAllBtn = createCustomToolbarButton({
        label: t('autoFitAll'),
        title: t('autoFitAllTitle'),
        icon: AUTO_ALL_ICON_SVG,
        className: 'custom-auto-all-btn',
        onClick: () => autoFitAll(xInstance),
      });

      group.append(rowBtn, colBtn, autoRowBtn, autoColBtn, autoAllBtn);
      toolbar.append(colorGroup, group);
    }
    function cleanupDrawioPanHandlers() {
      if (typeof disposeDrawioPanSurface === 'function') {
        disposeDrawioPanSurface();
        disposeDrawioPanSurface = null;
      }
      resetDrawioPanPosition = null;
    }
    function cleanupPdfViewer() {
      if (typeof disposePdfViewer === 'function') {
        disposePdfViewer();
        disposePdfViewer = null;
      }
    }
    function cleanupMarpitNavigation() {
      if (typeof disposeMarpitNavigation === 'function') {
        disposeMarpitNavigation();
        disposeMarpitNavigation = null;
      }
    }
    function cleanupWordToc() {
      if (typeof disposeWordToc === 'function') {
        disposeWordToc();
        disposeWordToc = null;
      }
      currentWordHeadingStyles = null;
      if (docPreviewEl) docPreviewEl.classList.remove('word-preview-active');
    }
    function setupPptxViewerNavigation(viewerEl) {
      if (!viewerEl) return;
      const scrollContainer = viewerEl;
      const state = {
        slides: [],
        activeIndex: 0,
        waitTimer: null,
        scrollRaf: null,
        disposed: false,
      };
      const MAX_POLL_COUNT = 200;
      const POLL_INTERVAL = 80;

      const stopWaiting = () => {
        if (state.waitTimer) {
          window.clearTimeout(state.waitTimer);
          state.waitTimer = null;
        }
      };

      const centerSlide = (slide, behavior = 'smooth') => {
        if (!slide || !scrollContainer) return;
        const containerRect = scrollContainer.getBoundingClientRect();
        const slideRect = slide.getBoundingClientRect();
        const offset = slideRect.top - containerRect.top + scrollContainer.scrollTop;
        const target = Math.max(offset - (scrollContainer.clientHeight - slideRect.height) / 2, 0);
        const scrollOptions = { top: target };
        if (behavior) scrollOptions.behavior = behavior;
        scrollContainer.scrollTo(scrollOptions);
      };

      const getClosestSlideIndex = () => {
        if (!state.slides.length) return 0;
        const containerRect = scrollContainer.getBoundingClientRect();
        const containerCenter = containerRect.top + containerRect.height / 2;
        let closestIndex = 0;
        let minDistance = Infinity;
        state.slides.forEach((slide, index) => {
          const rect = slide.getBoundingClientRect();
          const slideCenter = rect.top + rect.height / 2;
          const distance = Math.abs(slideCenter - containerCenter);
          if (distance < minDistance) {
            minDistance = distance;
            closestIndex = index;
          }
        });
        return closestIndex;
      };

      const updateActiveIndex = (index, options = {}) => {
        if (!state.slides.length) return;
        const clamped = Math.min(Math.max(index, 0), state.slides.length - 1);
        const shouldScroll = options.scroll !== false;
        const forceScroll = !!options.forceScroll;
        if (clamped === state.activeIndex && !forceScroll) {
          if (shouldScroll) centerSlide(state.slides[clamped], options.behavior || 'smooth');
          return;
        }
        const prevSlide = state.slides[state.activeIndex];
        if (prevSlide) prevSlide.classList.remove('pptx-slide--active');
        const nextSlide = state.slides[clamped];
        if (nextSlide) nextSlide.classList.add('pptx-slide--active');
        state.activeIndex = clamped;
        if (shouldScroll) {
          centerSlide(nextSlide, options.behavior || 'smooth');
        }
      };

      const handleKeyDown = (event) => {
        if (event.key !== 'PageDown' && event.key !== 'PageUp') return;
        if (!shouldHandleArrowNavigation(event)) return;
        if (!state.slides.length) return;
        const delta = event.key === 'PageDown' ? 1 : -1;
        const targetIndex = Math.min(
          Math.max(state.activeIndex + delta, 0),
          state.slides.length - 1,
        );
        if (targetIndex === state.activeIndex) return;
        event.preventDefault();
        updateActiveIndex(targetIndex, { behavior: 'smooth', forceScroll: true });
      };

      const handleScroll = () => {
        if (state.scrollRaf) return;
        state.scrollRaf = window.requestAnimationFrame(() => {
          state.scrollRaf = null;
          const closest = getClosestSlideIndex();
          if (closest !== state.activeIndex) {
            updateActiveIndex(closest, { scroll: false });
          }
        });
      };

      const teardown = () => {
        if (state.disposed) return;
        state.disposed = true;
        stopWaiting();
        if (state.scrollRaf) {
          window.cancelAnimationFrame(state.scrollRaf);
          state.scrollRaf = null;
        }
        scrollContainer.removeEventListener('scroll', handleScroll);
        window.removeEventListener('keydown', handleKeyDown);
        state.slides.forEach((slide) => slide.classList.remove('pptx-slide--active'));
        state.slides = [];
      };

      const initNavigation = (slides) => {
        state.slides = slides;
        if (!state.slides.length) return;
        scrollContainer.addEventListener('scroll', handleScroll, { passive: true });
        window.addEventListener('keydown', handleKeyDown);
        const initialIndex = getClosestSlideIndex();
        updateActiveIndex(initialIndex, { behavior: 'auto', forceScroll: true });
      };

      const waitForSlides = (attempt = 0) => {
        if (state.disposed) return;
        const nodes = Array.from(scrollContainer.querySelectorAll('.slide'))
          .filter((node) => node instanceof HTMLElement);
        if (nodes.length) {
          initNavigation(nodes);
          return;
        }
        if (attempt >= MAX_POLL_COUNT) return;
        state.waitTimer = window.setTimeout(() => {
          state.waitTimer = null;
          waitForSlides(attempt + 1);
        }, POLL_INTERVAL);
      };

      disposePptxViewer = teardown;
      waitForSlides();
    }
    function setupMarpitKeyboardNavigation(slideElements) {
      cleanupMarpitNavigation();
      if (!slideElements || !slideElements.length) return;

      const slides = Array.from(slideElements);
      const getViewportCenter = () => {
        const scrollTop = window.scrollY || document.documentElement.scrollTop || 0;
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
        return scrollTop + viewportHeight / 2;
      };
      const getCurrentSlideIndex = () => {
        const viewportCenter = getViewportCenter();
        let closestIndex = 0;
        let minDistance = Infinity;
        slides.forEach((slide, index) => {
          const rect = slide.getBoundingClientRect();
          const scrollTop = window.scrollY || document.documentElement.scrollTop || 0;
          const slideCenter = rect.top + scrollTop + rect.height / 2;
          const distance = Math.abs(slideCenter - viewportCenter);
          if (distance < minDistance) {
            minDistance = distance;
            closestIndex = index;
          }
        });
        return closestIndex;
      };

      const scrollToSlide = (index) => {
        const clamped = Math.min(Math.max(index, 0), slides.length - 1);
        const target = slides[clamped];
        if (target) target.scrollIntoView({ behavior: 'smooth', block: 'center' });
      };

      const handler = (event) => {
        if (event.key !== 'PageDown' && event.key !== 'PageUp') return;
        if (!shouldHandleArrowNavigation(event)) return;
        const direction = event.key === 'PageDown' ? 1 : -1;
        const currentIndex = getCurrentSlideIndex();
        const targetIndex = Math.min(Math.max(currentIndex + direction, 0), slides.length - 1);
        if (targetIndex === currentIndex) return;
        event.preventDefault();
        scrollToSlide(targetIndex);
      };

      window.addEventListener('keydown', handler);
      disposeMarpitNavigation = () => {
        window.removeEventListener('keydown', handler);
      };
    }
    function cleanupPptxViewer() { if (disposePptxViewer) { disposePptxViewer(); disposePptxViewer = null; } }
	    function cleanupMediaPreview() {
	       if (!docPreviewEl) return;
	       docPreviewEl.querySelectorAll('video, audio').forEach((el) => {
	         try { el.pause(); } catch {}
	         try {
	           el.removeAttribute('src');
	           if (typeof el.load === 'function') el.load();
	         } catch {}
	       });
	    }
	    function showPreviewPlaceholder(msg) {
	      imagePreviewWrapper.classList.add('hidden');
	      docPreviewEl.classList.remove('hidden');
	      showDocStatus(msg);
	    }

	    function clearLocalFileCache() {
	      localObjectUrlsByPath.forEach((url) => {
	        try { URL.revokeObjectURL(url); } catch {}
	      });
	      localObjectUrlsByPath.clear();
	      localFilesByPath.clear();
	      diskFilePathsByVirtualPath.clear();
	    }

	    function encodeAssetPath(path) {
	      if (!path) return path;
	      const value = String(path);
	      if (/^[a-zA-Z][a-zA-Z+.-]*:/.test(value)) return value;
	      return value.split('/').map((seg) => encodeURIComponent(seg)).join('/');
	    }

	    function getLocalFile(path) {
	      return localFilesByPath.get(path) || null;
	    }

	    function getDiskFilePath(path) {
	      return diskFilePathsByVirtualPath.get(path) || null;
	    }

	    function resolveResourceUrl(path) {
	      const file = getLocalFile(path);
	      if (file) {
	        if (!localObjectUrlsByPath.has(path)) {
	          localObjectUrlsByPath.set(path, URL.createObjectURL(file));
	        }
	        return localObjectUrlsByPath.get(path);
	      }
	      const diskPath = getDiskFilePath(path);
	      if (diskPath && tauriConvertFileSrc) {
	        return tauriConvertFileSrc(diskPath);
	      }
	      return encodeAssetPath(path);
	    }

	    async function fetchText(p) {
	      const file = getLocalFile(p);
	      if (file && typeof file.text === 'function') return await file.text();
	      const diskPath = getDiskFilePath(p);
	      if (diskPath && tauriConvertFileSrc) {
	        const r = await fetch(tauriConvertFileSrc(diskPath));
	        return await r.text();
	      }
	      const r = await fetch(encodeAssetPath(p));
	      return await r.text();
	    }

	    async function fetchBuffer(p) {
	      const file = getLocalFile(p);
	      if (file && typeof file.arrayBuffer === 'function') return await file.arrayBuffer();
	      const diskPath = getDiskFilePath(p);
	      if (diskPath && tauriConvertFileSrc) {
	        const r = await fetch(tauriConvertFileSrc(diskPath));
	        return await r.arrayBuffer();
	      }
	      const r = await fetch(encodeAssetPath(p));
	      return await r.arrayBuffer();
	    }

	    async function previewText(path) {
	       const text = await fetchText(path);
	       docPreviewEl.innerHTML = `<pre style="padding:1rem; white-space:pre-wrap;">${escapeHtml(text)}</pre>`;
	    }

    async function previewVideo(path) {
       docPreviewEl.innerHTML = `
         <div class="media-viewer media-viewer--video">
           <video class="media-viewer__video" controls controlslist="nodownload noplaybackrate noremoteplayback" disablepictureinpicture preload="metadata" playsinline></video>
         </div>`;

       const video = docPreviewEl.querySelector('video');
       if (!video) return;
       try {
         video.addEventListener('contextmenu', (event) => event.preventDefault());
         if ('disablePictureInPicture' in video) video.disablePictureInPicture = true;
         if ('disableRemotePlayback' in video) video.disableRemotePlayback = true;
         if (video.controlsList && typeof video.controlsList.add === 'function') {
           video.controlsList.add('nodownload');
           video.controlsList.add('noplaybackrate');
           video.controlsList.add('noremoteplayback');
         }
       } catch {}
	       video.src = resolveResourceUrl(path);
	    }

    async function previewAudio(path) {
       docPreviewEl.innerHTML = `
         <div class="media-viewer media-viewer--audio">
           <div class="media-viewer__audio-shell">
             <audio class="media-viewer__audio" controls controlslist="nodownload noplaybackrate noremoteplayback" preload="metadata"></audio>
           </div>
         </div>`;

       const audio = docPreviewEl.querySelector('audio');
       if (!audio) return;
       try {
         audio.addEventListener('contextmenu', (event) => event.preventDefault());
         if ('disableRemotePlayback' in audio) audio.disableRemotePlayback = true;
         if (audio.controlsList && typeof audio.controlsList.add === 'function') {
           audio.controlsList.add('nodownload');
           audio.controlsList.add('noplaybackrate');
           audio.controlsList.add('noremoteplayback');
         }
       } catch {}
	       audio.src = resolveResourceUrl(path);
	    }
    async function previewPdf(path) {
       const pdfjsLib = await ensurePdfJs();
       docPreviewEl.innerHTML = `
         <div class="pdf-viewer-wrapper">
           <div class="pdf-viewer">
             <div class="pdf-viewer__toolbar">
               <div class="pdf-group">
                 <button class="pdf-btn pdf-btn--icon" data-pdf-action="prev" disabled title="${escapeHtml(t('pdfPrev'))}">
                   <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7"></path></svg>
                 </button>
                 <span class="pdf-viewer__page-count" id="pdfPageInfo">-- / --</span>
                 <button class="pdf-btn pdf-btn--icon" data-pdf-action="next" disabled title="${escapeHtml(t('pdfNext'))}">
                   <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path></svg>
                 </button>
               </div>
               <div class="pdf-group">
                 <input type="number" min="1" id="pdfPageInput" class="pdf-input" placeholder="${escapeHtml(t('pdfPageInputPlaceholder'))}" disabled />
                 <button class="pdf-btn" data-pdf-action="jump" disabled>${escapeHtml(t('pdfJump'))}</button>
               </div>
               <div class="pdf-group">
                 <button class="pdf-btn pdf-btn--icon" data-pdf-action="zoom-out" disabled title="${escapeHtml(t('pdfZoomOut'))}">
                   <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M20 12H4"></path></svg>
                 </button>
                 <span class="pdf-viewer__zoom" id="pdfZoomLabel">100%</span>
                 <button class="pdf-btn pdf-btn--icon" data-pdf-action="zoom-in" disabled title="${escapeHtml(t('pdfZoomIn'))}">
                   <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4"></path></svg>
                 </button>
                                <button class="pdf-btn pdf-btn--icon" data-pdf-action="fit" disabled title="${escapeHtml(t('pdfFitWidth'))}">
                                  <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1h-4m4 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path></svg>
                                </button>
                              </div>
                              <div class="pdf-group">
                                <button class="pdf-btn pdf-btn--icon" data-pdf-action="toggle-drawer" title="${escapeHtml(t('pdfToc'))}">
                                  <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                                </button>
                              </div>
                            </div>
                            <div class="pdf-viewer__pages" id="pdfPages"></div>             <div class="pdf-viewer__status" id="pdfStatus">${escapeHtml(t('pdfLoading'))}</div>
           </div>
           <button class="pdf-bookmark-toggle" id="pdfBookmarkToggle" title="${escapeHtml(t('pdfViewBookmarks'))}">${escapeHtml(t('pdfBookmarks'))}</button>
           <aside class="pdf-bookmark-drawer" id="pdfBookmarkDrawer" aria-label="${escapeHtml(t('pdfBookmarksAria'))}">
            <div class="pdf-bookmark-drawer__header">
              <h3 class="pdf-bookmark-drawer__title">${escapeHtml(t('pdfToc'))}</h3>
              <button class="pdf-bookmark-drawer__close pdf-btn--icon" id="pdfBookmarkClose" data-pdf-action="close-drawer" title="${escapeHtml(t('pdfClose'))}">
                <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12"></path></svg>
              </button>
            </div>
             <div class="pdf-bookmark-drawer__search">
               <input type="text" id="pdfBookmarkSearch" class="pdf-input" placeholder="${escapeHtml(t('pdfSearchBookmarks'))}" />
             </div>
             <div class="pdf-bookmark-drawer__list" id="pdfBookmarkList"></div>
           </aside>
         </div>`;

       const pagesContainer = docPreviewEl.querySelector('#pdfPages');
       const statusEl = docPreviewEl.querySelector('#pdfStatus');
       const pageInfoEl = docPreviewEl.querySelector('#pdfPageInfo');
       const zoomLabel = docPreviewEl.querySelector('#pdfZoomLabel');
       const prevBtn = docPreviewEl.querySelector('[data-pdf-action="prev"]');
       const nextBtn = docPreviewEl.querySelector('[data-pdf-action="next"]');
       const zoomOutBtn = docPreviewEl.querySelector('[data-pdf-action="zoom-out"]');
       const zoomInBtn = docPreviewEl.querySelector('[data-pdf-action="zoom-in"]');
       const fitBtn = docPreviewEl.querySelector('[data-pdf-action="fit"]');
       const jumpBtn = docPreviewEl.querySelector('[data-pdf-action="jump"]');
       const pageInput = docPreviewEl.querySelector('#pdfPageInput');
       const bookmarkToggleBtn = docPreviewEl.querySelector('#pdfBookmarkToggle');
       const bookmarkDrawer = docPreviewEl.querySelector('#pdfBookmarkDrawer');
       const bookmarkSearchInput = docPreviewEl.querySelector('#pdfBookmarkSearch');
       const bookmarkListContainer = docPreviewEl.querySelector('#pdfBookmarkList');
       const bookmarkCloseBtn = docPreviewEl.querySelector('#pdfBookmarkClose');
       const controlButtons = [prevBtn, nextBtn, zoomOutBtn, zoomInBtn, fitBtn, jumpBtn];

       const setStatus = (msg) => {
         if (!statusEl) return;
         if (msg) {
           statusEl.textContent = msg;
           statusEl.style.display = 'block';
         } else {
           statusEl.textContent = '';
           statusEl.style.display = 'none';
         }
	       };

		       setStatus(t('pdfLoading'));
	       const pdfUrl = resolveResourceUrl(path);
	       const isLocalPdf = Boolean(getLocalFile(path));
	       let loadingTask = pdfjsLib.getDocument({ url: pdfUrl });
	       let pdfDoc = null;
	       let currentPage = 1;
	       let disposed = false;
       const isTransportDestroyed = (error) => (
         Boolean(error) && typeof error.message === 'string' && error.message.includes('Transport destroyed')
       );
       const isRetriableLoadError = (error) => {
         const name = typeof error?.name === 'string' ? error.name : '';
         const message = typeof error?.message === 'string' ? error.message : '';
         if (name === 'MissingPDFException' || message.includes('Missing PDF')) return true;
         if (name === 'UnexpectedResponseException' || message.includes('Unexpected server response')) return true;
         if (/Failed to fetch|NetworkError/i.test(message)) return true;
         return false;
       };
       const buildCacheBustedUrl = (url) => {
         try {
           const u = new URL(url, window.location.href);
           u.searchParams.set('_', String(Date.now()));
           return u.toString();
         } catch {
           return `${url}${url.includes('?') ? '&' : '?'}_=${Date.now()}`;
         }
       };
       let totalPages = 0;
       let scale = 1;
       let shouldMaintainFit = true;
       let handleResize = null;
       let pdfKeydownHandler = null;
       let bookmarkDrawerVisible = false;
       let pdfBookmarks = [];
       let bookmarkLoading = true;
       const pageElements = new Map();
       let goToPageRef = () => {};

       if (bookmarkToggleBtn) bookmarkToggleBtn.classList.add('loading');
       if (bookmarkSearchInput) bookmarkSearchInput.disabled = true;

       const endBookmarkLoading = (hasBookmarks = false) => {
         bookmarkLoading = false;
         if (bookmarkToggleBtn) {
           bookmarkToggleBtn.classList.remove('loading');
           bookmarkToggleBtn.style.display = hasBookmarks ? 'inline-flex' : 'none';
         }
         if (bookmarkSearchInput) bookmarkSearchInput.disabled = !hasBookmarks;
       };
       const MIN_SCALE = 0.6;
       const MAX_SCALE = 4;

       disposePdfViewer = () => {
         disposed = true;
         if (handleResize) {
           window.removeEventListener('resize', handleResize);
           handleResize = null;
         }
         if (pdfKeydownHandler) {
           window.removeEventListener('keydown', pdfKeydownHandler);
           pdfKeydownHandler = null;
         }
         if (pdfDoc) pdfDoc.cleanup();
         if (loadingTask && typeof loadingTask.destroy === 'function') loadingTask.destroy();
       };

       const updateZoomLabel = () => {
         zoomLabel.textContent = `${Math.round(scale * 100)}%`;
       };

       const updateNavButtons = () => {
         prevBtn.disabled = currentPage <= 1;
         nextBtn.disabled = currentPage >= totalPages;
         zoomInBtn.disabled = scale >= MAX_SCALE - 0.01;
         zoomOutBtn.disabled = scale <= MIN_SCALE + 0.01;
       };

       const ensurePageElement = (pageNumber) => {
         if (pageElements.has(pageNumber)) return pageElements.get(pageNumber);
         const wrapper = document.createElement('div');
         wrapper.className = 'pdf-page';
         wrapper.dataset.page = String(pageNumber);
         const canvas = document.createElement('canvas');
         const ctx = canvas.getContext('2d');
         const label = document.createElement('div');
         label.className = 'pdf-page__label';
	         label.textContent = t('pdfPageLabel', { page: pageNumber });
         wrapper.appendChild(canvas);
         wrapper.appendChild(label);
         pagesContainer.appendChild(wrapper);
         const entry = { wrapper, canvas, ctx, label };
         pageElements.set(pageNumber, entry);
         return entry;
       };

       const computeFitScale = async () => {
         const firstPage = await pdfDoc.getPage(1);
         const availableWidth = Math.max(pagesContainer.clientWidth - 32, 0);
         const unscaled = firstPage.getViewport({ scale: 1 });
         const fitScale = availableWidth ? availableWidth / unscaled.width : scale;
         return Math.min(MAX_SCALE, Math.max(MIN_SCALE, fitScale));
       };

       const setBookmarkDrawerVisible = (visible) => {
         // if (bookmarkLoading) return;
         bookmarkDrawerVisible = visible;
         if (bookmarkDrawer) {
           bookmarkDrawer.classList.toggle('open', visible);
	           if (visible && bookmarkLoading && bookmarkListContainer) {
	             bookmarkListContainer.innerHTML = `<div class="pdf-loading-spinner"></div><div style="text-align:center;color:#94a3b8;font-size:0.875rem;margin-top:0.5rem;">${escapeHtml(t('pdfLoadingBookmarks'))}</div>`;
	           }
         }
         if (!visible && bookmarkSearchInput) {
           bookmarkSearchInput.value = '';
           if (!bookmarkLoading) renderBookmarkList('');
         }
       };

       const renderBookmarkList = (term = '') => {
         if (!bookmarkListContainer) return;
         const normalized = term.trim().toLowerCase();
         const dataSource = normalized
           ? pdfBookmarks.filter(bm => bm.title.toLowerCase().includes(normalized))
           : pdfBookmarks;
	         if (!dataSource.length) {
	           const message = pdfBookmarks.length ? t('pdfNoMatchingBookmarks') : t('pdfNoBookmarks');
	           bookmarkListContainer.innerHTML = `<div class="pdf-bookmark-empty">${escapeHtml(message)}</div>`;
	           return;
	         }
         bookmarkListContainer.innerHTML = '';
         dataSource.forEach((bookmark, index) => {
           const item = document.createElement('button');
           item.type = 'button';
           item.className = 'pdf-bookmark';
           item.textContent = bookmark.title;
           item.title = bookmark.title;
           item.dataset.page = bookmark.page ? String(bookmark.page) : '';
           item.addEventListener('click', () => {
             if (bookmark.page) goToPageRef(bookmark.page);
             setBookmarkDrawerVisible(false);
           });
           bookmarkListContainer.appendChild(item);
         });
       };

       const resolveDestinationPage = async (dest) => {
         try {
           const target = typeof dest === 'string' ? await pdfDoc.getDestination(dest) : dest;
           if (!target || !target[0]) return null;
           const ref = target[0];
           const pageIndex = await pdfDoc.getPageIndex(ref);
           return pageIndex + 1;
         } catch {
           return null;
         }
       };

       const collectBookmarks = async (outlineItems) => {
         const results = [];
         if (!Array.isArray(outlineItems)) return results;
	         for (const item of outlineItems) {
	           const title = (item?.title || '').trim() || t('pdfUntitledBookmark');
           let page = null;
           if (item.dest) page = await resolveDestinationPage(item.dest);
           results.push({ title, page });
           if (Array.isArray(item.items) && item.items.length) {
             const children = await collectBookmarks(item.items);
             results.push(...children);
           }
         }
         return results;
       };

       const renderSinglePage = async (pageNumber) => {
          const entry = ensurePageElement(pageNumber);
          entry.wrapper.classList.add('pdf-page--rendering');
          let page;
          try {
            page = await pdfDoc.getPage(pageNumber);
          } catch (err) {
            entry.wrapper.classList.remove('pdf-page--rendering');
            if (isTransportDestroyed(err)) return;
            throw err;
          }
          const viewport = page.getViewport({ scale });
          const outputScale = Math.min(window.devicePixelRatio || 1, 2);
          entry.canvas.width = Math.floor(viewport.width * outputScale);
          entry.canvas.height = Math.floor(viewport.height * outputScale);
          entry.canvas.style.width = `${viewport.width}px`;
	          setStatus(t('pdfRenderStatus', { page: pageNumber, total: totalPages }));
          try {
            const renderContext = {
              canvasContext: entry.ctx,
              viewport,
              background: '#ffffff',
            };
            if (outputScale !== 1) {
              renderContext.transform = [outputScale, 0, 0, outputScale, 0, 0];
            }
            await page.render(renderContext).promise;
          } catch (err) {
            if (err && err.name === 'RenderingCancelledException') {
              entry.wrapper.classList.remove('pdf-page--rendering');
              setStatus('');
              return;
            }
            if (isTransportDestroyed(err)) {
              entry.wrapper.classList.remove('pdf-page--rendering');
              setStatus('');
              return;
            }
            throw err;
          }
          entry.wrapper.classList.remove('pdf-page--rendering');
       };

       const renderAllPages = async (fitWidth = false) => {
         if (fitWidth || shouldMaintainFit) {
           scale = await computeFitScale();
         }
         updateZoomLabel();
         for (let i = 1; i <= totalPages; i += 1) {
           await renderSinglePage(i);
         }
         setStatus('');
       };

       const syncPageIndicators = () => {
         pageInfoEl.textContent = `${currentPage} / ${totalPages}`;
         if (!pageInput.disabled) pageInput.value = currentPage;
         updateNavButtons();
       };

       const scrollToPage = (pageNumber, behavior = 'smooth') => {
         const entry = pageElements.get(pageNumber);
         if (!entry) return;
         const top = entry.wrapper.offsetTop;
         if (typeof pagesContainer.scrollTo === 'function') pagesContainer.scrollTo({ top, behavior });
         else pagesContainer.scrollTop = top;
       };

       const clampPage = (pageNumber) => Math.min(Math.max(pageNumber, 1), totalPages);
       const goToPage = (target) => {
         const desired = clampPage(target);
         scrollToPage(desired);
         currentPage = desired;
         syncPageIndicators();
       };
       goToPageRef = goToPage;

       const updateCurrentPageFromScroll = () => {
         if (!totalPages) return;
         const scrollTop = pagesContainer.scrollTop;
         let closestPage = currentPage;
         let minDistance = Infinity;
         pageElements.forEach((entry, pageNum) => {
           const distance = Math.abs(entry.wrapper.offsetTop - scrollTop);
           if (distance < minDistance) {
             minDistance = distance;
             closestPage = pageNum;
           }
         });
         closestPage = clampPage(closestPage);
         if (closestPage !== currentPage) {
           currentPage = closestPage;
           syncPageIndicators();
         }
       };

	       let loadError = null;
	       for (let attempt = 0; attempt < (isLocalPdf ? 1 : 2); attempt++) {
	         try {
		           if (attempt === 1) {
		             setStatus(t('pdfLoadFailedRetry'));
	             try {
	               if (loadingTask && typeof loadingTask.destroy === 'function') loadingTask.destroy();
             } catch {}
             await new Promise(resolve => setTimeout(resolve, 300));
             if (disposed) return;

	             const retryUrl = buildCacheBustedUrl(pdfUrl);
	             const res = await fetch(retryUrl);
	             if (disposed) return;
	             if (!res.ok) throw new Error(`Unexpected server response (${res.status}) while retrieving PDF "${path}".`);
	             const data = await res.arrayBuffer();
             if (disposed) return;
             loadingTask = pdfjsLib.getDocument({ data });
           }
           pdfDoc = await loadingTask.promise;
           if (disposed) return;
           loadError = null;
           break;
         } catch (error) {
           if (isTransportDestroyed(error)) {
             setStatus('');
             endBookmarkLoading(false);
             return;
           }
           loadError = error;
           if (attempt === 0 && isRetriableLoadError(error)) continue;
           setStatus('');
           endBookmarkLoading(false);
           cleanupPdfViewer();
	           showDocStatus(t('pdfLoadFailed', { message: error?.message || t('unknownError') }));
	           return;
	         }
	       }
       if (!pdfDoc) {
         setStatus('');
         endBookmarkLoading(false);
         cleanupPdfViewer();
	         showDocStatus(t('pdfLoadFailed', { message: loadError?.message || t('unknownError') }));
	         return;
	       }
       totalPages = pdfDoc.numPages;
       pageInfoEl.textContent = `1 / ${totalPages}`;
       pageInput.disabled = false;
       pageInput.min = 1;
       pageInput.max = totalPages;
       pageInput.value = 1;
       try {
         const outline = await pdfDoc.getOutline();
         pdfBookmarks = await collectBookmarks(outline);
         endBookmarkLoading(pdfBookmarks.length > 0);
       } catch (err) {
         if (isTransportDestroyed(err)) {
           endBookmarkLoading(false);
           return;
         }
         pdfBookmarks = [];
         endBookmarkLoading(false);
       }
       renderBookmarkList();
       setBookmarkDrawerVisible(false);

       await renderAllPages(true);
       pagesContainer.scrollTop = 0;
       updateCurrentPageFromScroll();
       controlButtons.forEach(btn => btn.disabled = false);
       syncPageIndicators();

       if (bookmarkToggleBtn) bookmarkToggleBtn.addEventListener('click', () => {
         setBookmarkDrawerVisible(!bookmarkDrawerVisible);
       });

       const toggleDrawerBtn = docPreviewEl.querySelector('[data-pdf-action="toggle-drawer"]');
       if (toggleDrawerBtn) {
          toggleDrawerBtn.addEventListener('click', () => {
             setBookmarkDrawerVisible(!bookmarkDrawerVisible);
          });
       }

       if (bookmarkCloseBtn) bookmarkCloseBtn.addEventListener('click', () => setBookmarkDrawerVisible(false));
       if (bookmarkSearchInput) bookmarkSearchInput.addEventListener('input', (event) => {
         if (bookmarkLoading) return;
         renderBookmarkList(event.target.value);
       });

       prevBtn.addEventListener('click', () => goToPage(currentPage - 1));
       nextBtn.addEventListener('click', () => goToPage(currentPage + 1));
       zoomInBtn.addEventListener('click', async () => {
         shouldMaintainFit = false;
         scale = Math.min(MAX_SCALE, scale + 0.2);
         await renderAllPages();
         syncPageIndicators();
       });
       zoomOutBtn.addEventListener('click', async () => {
         shouldMaintainFit = false;
         scale = Math.max(MIN_SCALE, scale - 0.2);
         await renderAllPages();
         syncPageIndicators();
       });
       fitBtn.addEventListener('click', async () => {
         shouldMaintainFit = true;
         await renderAllPages(true);
         syncPageIndicators();
       });
       jumpBtn.addEventListener('click', () => {
         const value = Number(pageInput.value);
         if (Number.isNaN(value)) return;
         goToPage(value);
       });
       pageInput.addEventListener('keydown', (event) => {
         if (event.key === 'Enter') {
           event.preventDefault();
           const value = Number(pageInput.value);
           if (!Number.isNaN(value)) goToPage(value);
         }
       });

       let scrollFrame = null;
       pagesContainer.addEventListener('scroll', () => {
         if (scrollFrame) return;
         scrollFrame = requestAnimationFrame(() => {
           scrollFrame = null;
           updateCurrentPageFromScroll();
         });
       });

       handleResize = async () => {
         if (shouldMaintainFit) {
           await renderAllPages(true);
           syncPageIndicators();
         }
       };
       window.addEventListener('resize', handleResize);

       pdfKeydownHandler = (event) => {
         if (!shouldHandleArrowNavigation(event)) return;
         if (event.key === 'PageDown') {
           event.preventDefault();
           goToPage(currentPage + 1);
         } else if (event.key === 'PageUp') {
           event.preventDefault();
           goToPage(currentPage - 1);
         }
       };
       window.addEventListener('keydown', pdfKeydownHandler);
    }
    async function previewWord(path) {
       cleanupWordToc();
       const buff = await fetchBuffer(path);
       const headingStylesPromise = parseDocxHeadingStyles(buff);
       docPreviewEl.innerHTML = '';
       await window.docx.renderAsync(buff, docPreviewEl);
       const wordRoot = docPreviewEl.querySelector('.docx-wrapper') || docPreviewEl;
       currentWordHeadingStyles = await headingStylesPromise;
       setupWordToc(wordRoot, currentWordHeadingStyles);
    }
    const WORD_NAMESPACE = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
    function normalizeDocxStyleName(name) {
      if (!name) return '';
      return String(name).trim().toLowerCase().replace(/[ .]+/g, '-').replace(/[&]+/g, 'and');
    }
    function getWordAttr(element, attr) {
      if (!element || !attr) return null;
      return element.getAttribute(attr) || element.getAttribute(`w:${attr}`) || (element.getAttributeNS ? element.getAttributeNS(WORD_NAMESPACE, attr) : null);
    }
    function inferHeadingLevelFromName(nameValue) {
      if (!nameValue) return null;
      const normalized = String(nameValue).trim().toLowerCase();
      let match = normalized.match(/heading(?:[\s\-]?)([0-9]+)/);
      if (!match) match = normalized.match(/标题(?:[\s\-]?)([0-9]+)/);
      if (!match) match = normalized.match(/title(?:[\s\-]?)([0-9]+)/);
      if (match) {
        const lvl = Number(match[1]);
        if (!Number.isNaN(lvl)) return lvl;
      }
      if (normalized.includes('heading') || normalized.includes('标题')) return 2;
      if (normalized.includes('title')) return 1;
      return null;
    }
    function resolveHeadingLevelFromStyle(styleEl) {
      if (!styleEl) return null;
      const outlineEl = styleEl.getElementsByTagNameNS ? styleEl.getElementsByTagNameNS(WORD_NAMESPACE, 'outlineLvl')[0] : null;
      if (outlineEl) {
        const val = getWordAttr(outlineEl, 'val');
        if (val !== null && val !== undefined && val !== '') {
          const parsed = Number(val);
          if (!Number.isNaN(parsed)) return parsed + 1;
        }
      }
      const nameEl = styleEl.getElementsByTagNameNS ? styleEl.getElementsByTagNameNS(WORD_NAMESPACE, 'name')[0] : null;
      const nameValue = getWordAttr(nameEl, 'val');
      return inferHeadingLevelFromName(nameValue);
    }
    async function parseDocxHeadingStyles(buffer) {
      if (!buffer || !window.JSZip) return null;
      try {
        const zip = await window.JSZip.loadAsync(buffer);
        const stylesEntry = zip.file('word/styles.xml');
        if (!stylesEntry) return null;
        const xmlText = await stylesEntry.async('string');
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlText, 'application/xml');
        const styleEls = Array.from(xmlDoc.getElementsByTagNameNS ? xmlDoc.getElementsByTagNameNS(WORD_NAMESPACE, 'style') : xmlDoc.getElementsByTagName('w:style'));
        if (!styleEls.length) return null;
        const headingMap = new Map();
        styleEls.forEach((styleEl) => {
          const styleId = getWordAttr(styleEl, 'styleId');
          if (!styleId) return;
          const level = resolveHeadingLevelFromStyle(styleEl);
          if (!level) return;
          const normalizedId = normalizeDocxStyleName(styleId);
          if (!normalizedId) return;
          const className = `${DOCX_STYLE_PREFIX}_${normalizedId}`;
          if (!headingMap.has(className)) headingMap.set(className, { level, styleId });
        });
        return headingMap.size ? headingMap : null;
      } catch (error) {
        console.warn('解析 Word 样式失败', error);
        return null;
      }
    }
    function resolveWordHeadingInfo(node, headingStyles) {
      if (!node) return null;
      const styleInfo = getHeadingInfoFromStyles(node, headingStyles);
      if (styleInfo) return styleInfo;
      const fallbackLevel = getWordHeadingLevel(node);
      if (fallbackLevel) return { level: fallbackLevel };
      return null;
    }
    function getHeadingInfoFromStyles(node, headingStyles) {
      if (!headingStyles || !node?.classList) return null;
      for (const cls of node.classList) {
        if (!cls) continue;
        const entry = headingStyles.get(cls);
        if (entry) return entry;
      }
      return null;
    }
    function getWordHeadingLevel(node) {
      if (!node) return null;
      const tag = node.tagName ? node.tagName.toUpperCase() : '';
      if (/^H[1-6]$/.test(tag)) return Number(tag.substring(1));
      const classList = Array.from(node.classList || []);
      if (!classList.length) return null;
      for (const cls of classList) {
        const normalized = cls.toLowerCase();
        if (!normalized.includes('heading') && !normalized.includes('标题') && !normalized.includes('title')) continue;
        const headingMatch = normalized.match(/heading[-_\s]?([0-9]+)/);
        const chineseMatch = normalized.match(/标题[-_\s]?([0-9]+)/);
        const digits = headingMatch?.[1] || chineseMatch?.[1];
        if (digits) {
          const level = Number(digits);
          if (!Number.isNaN(level)) return Math.min(Math.max(level, 1), 6);
        }
        if (normalized.includes('heading') || normalized.includes('标题')) return 2;
        if (normalized.includes('title')) return 1;
      }
      return null;
    }
    function buildWordHeadingEntries(root, headingStyles) {
      if (!root) return [];
      const slugCounts = new Map();
      const nodes = root.querySelectorAll('p, h1, h2, h3, h4, h5, h6');
      const entries = [];
      nodes.forEach((node) => {
        const text = node.textContent?.trim();
        if (!text) return;
        const headingInfo = resolveWordHeadingInfo(node, headingStyles);
        const level = headingInfo?.level;
        if (!level) return;
        let anchorId = node.id;
        const base = slugify(text) || `word-heading-${entries.length + 1}`;
        if (!anchorId) {
          const count = slugCounts.get(base) || 0;
          slugCounts.set(base, count + 1);
          anchorId = count ? `${base}-${count}` : base;
          node.id = anchorId;
        }
        entries.push({ id: anchorId, text, level, element: node });
      });
      return entries;
    }
    function getWordScrollContainer() {
      if (!docPreviewEl) return null;
      const container = docPreviewEl.closest('.preview__content');
      return container || docPreviewEl;
    }
    function setupWordToc(root, headingStyles) {
      if (!docPreviewEl || !root) return;
      const headings = buildWordHeadingEntries(root, headingStyles);
      const hasHeadings = headings.length > 0;
      if (!hasHeadings) {
        docPreviewEl.classList.remove('word-preview-active');
        return;
      }
      docPreviewEl.classList.add('word-preview-active');

      const toggleIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
      const closeIcon = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;

      const toggleBtn = document.createElement('button');
      toggleBtn.type = 'button';
      toggleBtn.className = 'word-floating-toggle';
      toggleBtn.title = t('wordShowToc');
      toggleBtn.innerHTML = toggleIcon;

      const panel = document.createElement('aside');
      panel.className = 'word-toc-panel';
      panel.innerHTML = `
        <div class="word-toc__header">
          <span>${escapeHtml(t('wordTocTitle'))}</span>
          <button type="button" class="word-toc__close" aria-label="${escapeHtml(t('wordCloseToc'))}" title="${escapeHtml(t('wordCloseToc'))}">${closeIcon}</button>
        </div>
        <div class="word-toc__search">
          <input type="text" class="input" placeholder="${escapeHtml(t('wordSearchHeadings'))}" />
        </div>
        <div class="word-toc__list" role="navigation" aria-label="${escapeHtml(t('wordTocAria'))}"></div>
      `;

      docPreviewEl.appendChild(toggleBtn);
      docPreviewEl.appendChild(panel);

      const listEl = panel.querySelector('.word-toc__list');
      const searchInput = panel.querySelector('.word-toc__search .input');
      const closeBtn = panel.querySelector('.word-toc__close');
      const scrollContainer = getWordScrollContainer();

      const scrollToHeading = (entry) => {
        if (!entry?.element || !scrollContainer) return;
        const containerRect = scrollContainer.getBoundingClientRect();
        const targetRect = entry.element.getBoundingClientRect();
        const offset = targetRect.top - containerRect.top + scrollContainer.scrollTop;
        scrollContainer.scrollTo({ top: Math.max(offset - 40, 0), behavior: 'smooth' });
      };

      const renderList = (items, isFiltered = false) => {
        if (!listEl) return;
        listEl.innerHTML = '';
        if (!items.length) {
          const message = hasHeadings && isFiltered ? t('wordNoMatchingHeadings') : t('wordNoHeadings');
          listEl.innerHTML = `<div class="word-toc__empty">${escapeHtml(message)}</div>`;
          return;
        }
        items.forEach((entry) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'word-toc-item';
          button.dataset.target = entry.id;
          button.textContent = entry.text;
          button.style.paddingLeft = `${12 + (entry.level - 1) * 16}px`;
          button.addEventListener('click', () => {
            scrollToHeading(entry);
            setPanelVisible(false);
          });
          listEl.appendChild(button);
        });
      };

      const setPanelVisible = (visible) => {
        panel.classList.toggle('word-toc-panel--open', visible);
        toggleBtn.classList.toggle('hidden', visible);
        if (!visible && searchInput) {
          searchInput.value = '';
          renderList(headings);
        }
      };

      if (searchInput) {
        searchInput.disabled = !hasHeadings;
        if (!hasHeadings) searchInput.placeholder = t('wordNoHeadingsDetected');
        searchInput.addEventListener('input', (event) => {
          const term = event.target.value.trim().toLowerCase();
          if (!term) {
            renderList(headings);
            return;
          }
          const filtered = headings.filter((entry) => entry.text.toLowerCase().includes(term));
          renderList(filtered, true);
        });
      }

      toggleBtn.addEventListener('click', () => setPanelVisible(true));
      closeBtn?.addEventListener('click', () => setPanelVisible(false));
      renderList(headings);
      setPanelVisible(false);

      disposeWordToc = () => {
        toggleBtn.remove();
        panel.remove();
        docPreviewEl.classList.remove('word-preview-active');
      };
    }
    function stox(wb) {
      const out = [];
      wb.SheetNames.forEach(name => {
        const o = { name: name, rows: {}, cols: {}, merges: [], styles: [] };
        const ws = wb.Sheets[name];
        if(!ws || !ws['!ref']) return;
        const range = window.XLSX.utils.decode_range(ws['!ref']);
        
        if (ws['!cols']) {
            ws['!cols'].forEach((col, i) => {
                if (col) o.cols[i] = { width: (col.wpx || (col.width || 10) * 7.5) }; 
            });
        }
        
        if (ws['!rows']) {
            ws['!rows'].forEach((row, i) => {
                if (row) {
                    if (!o.rows[i]) o.rows[i] = { cells: {} };
                    o.rows[i].height = row.hpx || row.hpt || 25;
                }
            });
        }

        for(let R = range.s.r; R <= range.e.r; ++R) {
          for(let C = range.s.c; C <= range.e.c; ++C) {
            const cell_address = window.XLSX.utils.encode_cell({r:R, c:C});
            const cell = ws[cell_address];
            if(!cell) continue;
            if (!o.rows[R]) o.rows[R] = { cells: {} };
            if (!o.rows[R].cells[C]) o.rows[R].cells[C] = {};
            o.rows[R].cells[C].text = (cell.w || cell.v || '') + ''; 
          }
        }
        
        if(ws['!merges']) {
          ws['!merges'].forEach(merge => {
             const r = merge.s.r;
             const c = merge.s.c;
             if (!o.rows[r]) o.rows[r] = { cells: {} };
             if (!o.rows[r].cells[c]) o.rows[r].cells[c] = {};
             o.rows[r].cells[c].merge = [merge.e.r - r, merge.e.c - c];
          });
        }
        out.push(o);
      });
      return out;
    }

        async function previewExcel(path) {
           setExcelPreviewState(true);
            try {
                const buff = await fetchBuffer(path);
                const wb = window.XLSX.read(buff, {type:'array'});
                const data = stox(wb);
                
                docPreviewEl.innerHTML = '<div id="xspreadsheet"></div>';
                // Ensure styles are loaded
                if (!window.x_spreadsheet) {
                     docPreviewEl.innerHTML = '<div style="padding:1rem;color:red;">x-spreadsheet library not loaded</div>';
                     return;
                }
    
                const x = new window.x_spreadsheet('#xspreadsheet', {
                    showToolbar: true,
                    showGrid: true,
                    showContextmenu: true,
                    view: {
                        height: () => docPreviewEl.clientHeight,
                        width: () => docPreviewEl.clientWidth,
                    },
                    row: {
                        len: 100,
                        height: 25,
                    },
                    col: {
                        len: 26,
                        width: 100,
                        indexWidth: 60,
                        minWidth: 60,
                    },
                    style: {
                        bgcolor: '#ffffff',
                        align: 'left',
                        valign: 'middle',
                        textwrap: false,
                        strike: false,
                        underline: false,
                        color: '#0a0a0a',
                        font: {
                          name: 'Arial',
                          size: 10,
                          bold: false,
                          italic: false,
                        },
                    },
                });
                x.loadData(data);
                customizeSpreadsheetToolbar(x);
                try {
                    autoFitAll(x);
                } catch (autoFitError) {
                    console.warn('Auto fit failed:', autoFitError);
                }

                // Handle resize
                if (docPreviewEl._resizeObserver) {
                    docPreviewEl._resizeObserver.disconnect();
                }
                docPreviewEl._resizeObserver = new ResizeObserver(() => {
                    x.reRender();
                });
                docPreviewEl._resizeObserver.observe(docPreviewEl);
            } catch (error) {
                setExcelPreviewState(false);
                throw error;
            }
        }
    async function previewSlides(path) {
       cleanupPptxViewer();
       docPreviewEl.innerHTML = '<div id="pptxViewer" class="pptx-viewer"></div>';
       
	       $('#pptxViewer').pptxToHtml({ 
	         pptxFileUrl: resolveResourceUrl(path), 
	         slidesScale: '100%', 
	         slideMode: false, 
	         keyBoardShortCut: false,
	         jsZipV2: 'assets/jszip.v2.min.js',
         mediaProcess: true
       });
       const viewerRoot = document.getElementById('pptxViewer');
       if (viewerRoot) setupPptxViewerNavigation(viewerRoot);
    }
    async function previewMindmap(path) {
       const txt = await fetchText(path);
       docPreviewEl.innerHTML = '<svg id="mm" style="width:100%;height:100%"></svg>';
       const { Markmap, loadCSS, loadJS } = window.markmap;
       const transformer = new window.markmap.Transformer();
       const { root, features } = transformer.transform(txt);
       Markmap.create('#mm', { autoFit: true }, root);
    }

    function setupDrawioPanSurface(surface, canvas, shell) {
       if (!surface || !canvas || !shell) return null;

       canvas.style.width = `${DRAWIO_PAN_CANVAS_SIZE}px`;
       canvas.style.height = `${DRAWIO_PAN_CANVAS_SIZE}px`;

       let pointerId = null;
       let startX = 0;
       let startY = 0;
       let panX = 0;
       let panY = 0;
       let originPanX = 0;
       let originPanY = 0;

       const updatePan = () => {
         canvas.style.transform = `translate3d(${panX}px, ${panY}px, 0)`;
       };

       const syncShellSize = () => {
         const rect = surface.getBoundingClientRect();
         shell.style.width = `${rect.width}px`;
         shell.style.height = `${rect.height}px`;
       };

       const centerCanvas = () => {
         const rect = surface.getBoundingClientRect();
         panX = (rect.width - DRAWIO_PAN_CANVAS_SIZE) / 2;
         panY = (rect.height - DRAWIO_PAN_CANVAS_SIZE) / 2;
         updatePan();
       };

       const stopDragging = () => {
         if (pointerId === null) return;
         pointerId = null;
         surface.classList.remove('is-dragging');
       };

       const pointerDownOptions = { capture: true };

       const handlePointerDown = (evt) => {
         if (pointerId !== null) return;
         if (typeof evt.button === 'number' && evt.button !== 0) return;
         pointerId = evt.pointerId;
         startX = evt.clientX;
         startY = evt.clientY;
         originPanX = panX;
         originPanY = panY;
         surface.classList.add('is-dragging');
         evt.preventDefault();
       };

       const handlePointerMove = (evt) => {
         if (pointerId !== evt.pointerId) return;
         panX = originPanX + (evt.clientX - startX);
         panY = originPanY + (evt.clientY - startY);
         updatePan();
         evt.preventDefault();
       };

       const handlePointerUp = (evt) => {
         if (pointerId !== evt.pointerId) return;
         stopDragging();
       };

       const cancelFromBlur = () => stopDragging();

       surface.addEventListener('pointerdown', handlePointerDown, pointerDownOptions);
       window.addEventListener('pointermove', handlePointerMove);
       window.addEventListener('pointerup', handlePointerUp);
       window.addEventListener('pointercancel', handlePointerUp);
       window.addEventListener('blur', cancelFromBlur);

       const handleResize = () => {
         syncShellSize();
         updatePan();
       };
       let cleanupResize = null;
       if (typeof window.ResizeObserver === 'function') {
         const observer = new window.ResizeObserver(() => handleResize());
         observer.observe(surface);
         cleanupResize = () => observer.disconnect();
       } else {
         window.addEventListener('resize', handleResize);
         cleanupResize = () => window.removeEventListener('resize', handleResize);
       }

       syncShellSize();
       centerCanvas();
       if (typeof window.requestAnimationFrame === 'function') {
         window.requestAnimationFrame(() => {
           syncShellSize();
           centerCanvas();
         });
       }

        return {
          center: centerCanvas,
          cleanup: () => {
           surface.removeEventListener('pointerdown', handlePointerDown, pointerDownOptions);
           window.removeEventListener('pointermove', handlePointerMove);
           window.removeEventListener('pointerup', handlePointerUp);
           window.removeEventListener('pointercancel', handlePointerUp);
           window.removeEventListener('blur', cancelFromBlur);
           if (typeof cleanupResize === 'function') cleanupResize();
           stopDragging();
           surface.classList.remove('is-dragging');
         }
       };
    }
    async function previewDrawio(path) {
       const xml = await fetchText(path);
       const iconZoomIn = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>`;
       const iconZoomOut = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>`;
       const iconReset = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>`;
       const iconFit = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>`;

       docPreviewEl.innerHTML = `
         <div class="drawio-wrapper">
           <div class="drawio-pan-surface">
             <div class="drawio-pan-canvas">
               <div class="drawio-graph-shell">
                 <div class="mxgraph" style="width:100%;height:100%;"></div>
               </div>
             </div>
	           </div>
	           <div class="drawio-toolbar">
	             <button class="btn" id="dioZoomIn" title="${escapeHtml(t('zoomIn'))}">${iconZoomIn}</button>
	             <button class="btn" id="dioZoomOut" title="${escapeHtml(t('zoomOut'))}">${iconZoomOut}</button>
	             <button class="btn" id="dioFit" title="${escapeHtml(t('fitWindow'))}">${iconFit}</button>
	             <button class="btn" id="dioReset" title="${escapeHtml(t('resetView'))}">${iconReset}</button>
	           </div>
	         </div>`;

       const host = docPreviewEl.querySelector('.drawio-graph-shell .mxgraph');
       host.setAttribute('data-mxgraph', JSON.stringify({xml, zoom:1, nav:false, resize:false, lightbox:0}));
       const panSurface = docPreviewEl.querySelector('.drawio-pan-surface');
       const panCanvas = docPreviewEl.querySelector('.drawio-pan-canvas');
       const graphShell = docPreviewEl.querySelector('.drawio-graph-shell');
       const panController = setupDrawioPanSurface(panSurface, panCanvas, graphShell);
       if (panController) {
          disposeDrawioPanSurface = panController.cleanup;
          resetDrawioPanPosition = panController.center;
       }

       const zoomInBtn = docPreviewEl.querySelector('#dioZoomIn');
       const zoomOutBtn = docPreviewEl.querySelector('#dioZoomOut');
       const fitBtn = docPreviewEl.querySelector('#dioFit');
       const resetBtn = docPreviewEl.querySelector('#dioReset');
       
       window.GraphViewer.createViewerForElement(host, function(viewer) {
           if(viewer && viewer.graph) {
               const graph = viewer.graph;

               if (zoomInBtn) zoomInBtn.addEventListener('click', () => graph.zoomIn());
               if (zoomOutBtn) zoomOutBtn.addEventListener('click', () => graph.zoomOut());
               if (fitBtn) fitBtn.addEventListener('click', () => {
                  graph.fit();
                  if (typeof resetDrawioPanPosition === 'function') resetDrawioPanPosition();
               });
               if (resetBtn) resetBtn.addEventListener('click', () => {
                  graph.zoomTo(1);
                  graph.center();
                  if (typeof resetDrawioPanPosition === 'function') resetDrawioPanPosition();
               });
           }
       });
    }
    async function previewMarpit(path) {
       const txt = await fetchText(path);
       if(!marpitInstance) marpitInstance = new window.marpit.Marpit({ markdown: ['default', { html: true }] });
       const {html, css} = marpitInstance.render(txt);
       const navIcon = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>`;
       const closeIcon = `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
       docPreviewEl.innerHTML = `
         <style>${css}</style>
         <style>${MARPIT_CUSTOM_STYLE}</style>
	         <div class="marpit-preview">
	          <aside class="marpit-toc collapsed" id="marpitToc">
	            <div class="marpit-toc__header">
	              <span>${escapeHtml(t('marpitNav'))}</span>
	              <button type="button" class="marpit-toc__close" id="closeMarpitToc" aria-label="${escapeHtml(t('close'))}" title="${escapeHtml(t('close'))}">${closeIcon}</button>
	            </div>
	            <div class="marpit-toc__body">
	              <div class="marpit-toc__search">
	                <input type="text" id="marpitTocSearch" class="input" placeholder="${escapeHtml(t('searchToc'))}" />
	              </div>
	              <div class="marpit-toc__list" id="marpitTocList"></div>
	            </div>
	          </aside>
	           <button id="marpitTocToggle" type="button" class="marpit-floating-toggle" title="${escapeHtml(t('showToc'))}">${navIcon}</button>
	           <div class="marpit-wrapper">${html}</div>
	         </div>
	       `;

       const marpitWrapper = docPreviewEl.querySelector('.marpit-wrapper');
       const slides = marpitWrapper ? marpitWrapper.querySelectorAll('section') : [];
       const tocList = docPreviewEl.querySelector('#marpitTocList');
       const toggleBtn = docPreviewEl.querySelector('#marpitTocToggle');
       const toc = docPreviewEl.querySelector('#marpitToc');
       const closeBtn = docPreviewEl.querySelector('#closeMarpitToc');
       const searchInput = docPreviewEl.querySelector('#marpitTocSearch');

       const setTocVisibility = (visible) => {
         if (!toc || !toggleBtn) return;
         if (visible) {
           toc.classList.remove('collapsed');
           toggleBtn.classList.add('hidden');
           if (searchInput) {
             searchInput.value = '';
             searchInput.dispatchEvent(new Event('input'));
             searchInput.focus();
           }
         } else {
           toc.classList.add('collapsed');
           toggleBtn.classList.remove('hidden');
         }
       };

       const tocItems = [];
	       slides.forEach((slide, index) => {
	         const heading = slide.querySelector('h1, h2, h3, h4, h5, h6');
	         const text = heading ? heading.textContent.trim() : '';
	         const label = text || t('pdfPageLabel', { page: index + 1 });
	         const slideId = `marpit-slide-${index}`;
	         slide.setAttribute('id', slideId);
         if (!tocList) return;
         const button = document.createElement('button');
         button.type = 'button';
         button.className = 'marpit-toc-item';
         button.textContent = label;
         button.dataset.target = slideId;
         button.addEventListener('click', () => {
           const target = document.getElementById(slideId);
           if (target) target.scrollIntoView({ behavior: 'smooth', block: 'center' });
           setTocVisibility(false);
         });
         tocList.appendChild(button);
         tocItems.push(button);
       });

	       if (!tocItems.length) {
	         if (toggleBtn) toggleBtn.classList.add('hidden');
	         if (toc) toc.classList.add('marpit-toc--empty');
	         if (searchInput) searchInput.disabled = true;
	         return;
	       }

	       setTocVisibility(false);
	       if (toggleBtn) toggleBtn.addEventListener('click', () => setTocVisibility(true));
	       if (closeBtn) closeBtn.addEventListener('click', () => setTocVisibility(false));
	       if (searchInput) {
	         searchInput.addEventListener('input', (event) => {
	           const term = event.target.value.trim().toLowerCase();
	           tocItems.forEach(item => {
	             const matches = item.textContent.toLowerCase().includes(term);
	             item.style.display = matches ? 'block' : 'none';
	           });
	         });
	       }

	       renderLatexInContainer(marpitWrapper);
	       setupMarpitKeyboardNavigation(slides);
	    }

    function updateImageTransform() {
       singleImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${zoomLevel})`;
    }

    function resetZoom() {
       zoomLevel = 1; 
       translateX = 0;
       translateY = 0;
       updateImageTransform();
    }

    zoomContainer.addEventListener('wheel', (e) => {
       if(imagePreviewWrapper.classList.contains('hidden')) return;
       e.preventDefault();
       const delta = e.deltaY * -0.001;
       zoomLevel += delta;
       zoomLevel = Math.min(Math.max(MIN_ZOOM, zoomLevel), MAX_ZOOM);
       updateImageTransform();
    });

    // Image Dragging Logic
    zoomContainer.style.cursor = 'grab';

    zoomContainer.addEventListener('mousedown', (e) => {
      if (imagePreviewWrapper.classList.contains('hidden')) return;
      e.preventDefault();
      isDragging = true;
      startX = e.clientX - translateX;
      startY = e.clientY - translateY;
      zoomContainer.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      translateX = e.clientX - startX;
      translateY = e.clientY - startY;
      updateImageTransform();
    });

    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        zoomContainer.style.cursor = 'grab';
      }
    });

    zoomContainer.addEventListener('dblclick', () => resetZoom());

    const shouldHandleArrowNavigation = (event) => {
      const target = event.target;
      if (!target) return true;
      const tag = target.tagName;
      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(tag)) {
        return false;
      }
      if (target.isContentEditable) return false;
      if (target.closest('.tree__group')) { // Updated class name
        return false;
      }
      return true;
    };

    const navigateByOffset = (offset) => {
      if (!filteredFiles.length) return;
      setCurrentFile(currentIndex + offset);
    };

    window.addEventListener('keydown', (event) => {
      if (!shouldHandleArrowNavigation(event)) return;
      if (event.key === 'ArrowRight') {
        navigateByOffset(1);
        event.preventDefault();
      } else if (event.key === 'ArrowLeft') {
        navigateByOffset(-1);
        event.preventDefault();
      }
    });

    prevBtn.addEventListener('click', () => navigateByOffset(-1));
    nextBtn.addEventListener('click', () => navigateByOffset(1));
    toggleFullscreenBtn.addEventListener('click', () => {
       if(!document.fullscreenElement) previewCardEl.requestFullscreen();
       else document.exitFullscreen();
    });
    treeSearchInput.addEventListener('input', (e) => { treeSearchTerm = e.target.value; renderTree(); });
    treeSearchClear.addEventListener('click', () => { treeSearchInput.value = ''; treeSearchTerm = ''; renderTree(); treeSearchClear.classList.add('hidden'); });
	    treeSearchInput.addEventListener('keyup', () => {
	       if(treeSearchInput.value) treeSearchClear.classList.remove('hidden');
	       else treeSearchClear.classList.add('hidden');
	    });

	    function normalizeSelectedPath(file) {
	      const raw = file?.webkitRelativePath || file?.name || '';
	      return String(raw)
	        .replace(/\\/g, '/')
	        .replace(/^\.\//, '')
	        .replace(/^\/+/, '');
	    }

	    function getCommonRootFolder(paths) {
	      if (!paths.length) return null;
	      const first = paths[0].split('/')[0];
	      if (!first) return null;
	      if (paths.every((p) => p === first || p.startsWith(`${first}/`))) return first;
	      return null;
	    }

	    function normalizeVirtualPath(value) {
	      return String(value || '')
	        .replace(/\\/g, '/')
	        .replace(/^\.\//, '')
	        .replace(/^\/+/, '');
	    }

	    function applyScannedFolderSelection(scan) {
	      const entries = Array.from(scan?.files || []).filter((f) => f && typeof f === 'object');

	      cleanupDrawioPanHandlers();
	      cleanupPptxViewer();
	      cleanupMarpitNavigation();
	      cleanupPdfViewer();
	      cleanupMediaPreview();
	      cleanupWordToc();
	      cleanupExcelPreview();
		      try { singleImage.removeAttribute('src'); } catch {}

		      clearLocalFileCache();
		      hasUserSelection = true;

		      const categories = {};
		      entries.forEach((entry) => {
		        const virtualPath = normalizeVirtualPath(entry?.virtualPath);
		        const absPath = entry?.absPath;
		        const type = entry?.category || categorizePath(virtualPath);
		        if (!virtualPath || !absPath || !type) return;
		        if (!categories[type]) categories[type] = [];
		        categories[type].push(virtualPath);
		        diskFilePathsByVirtualPath.set(virtualPath, absPath);
		      });

		      Object.values(categories).forEach((paths) => paths.sort(compareNames));

		      fileGroups = [{ path: '.', categories }];
		      currentCategory = 'all';
		      currentIndex = 0;
		      treeSearchTerm = '';
		      if (treeSearchInput) {
		        treeSearchInput.value = '';
		        treeSearchInput.disabled = false;
		      }
		      if (treeSearchClear) treeSearchClear.classList.add('hidden');

	      const label = scan?.label || scan?.root || t('openedFolder');
	      currentSourceKind = 'local';
	      currentSourceName = label || '';
	      updateCurrentSourceLabel();

	      renderCategoryFilters();
	      renderTree();

	      if (filteredFiles.length > 0) {
	        setCurrentFile(0);
	      } else {
	        showPreviewPlaceholder(t('emptyNoPreviewable'));
	      }
	    }

			    async function requestOpenFolder() {
			      if (!tauriInvoke) {
			        if (openFolderInput) openFolderInput.click();
			        return;
			      }

		      const scan_id = showScanOverlay ? showScanOverlay() : null;
		      try {
		        const scan = await tauriInvoke('pick_and_scan_folder', scan_id ? { scan_id } : undefined);
		        if (!scan) return;
		        applyScannedFolderSelection(scan);
		      } catch (error) {
		        console.error(error);
		        showPreviewPlaceholder(t('openFolderFailed', { message: error?.message || String(error) }));
		      } finally {
		        if (typeof hideScanOverlay === 'function') hideScanOverlay();
			      }
			    }

			    async function requestOpenFile() {
			      if (!tauriInvoke) {
			        if (openFileInput) openFileInput.click();
			        return;
			      }

			      const scan_id = showScanOverlay ? showScanOverlay() : null;
			      try {
			        const scan = await tauriInvoke('pick_and_scan_file', scan_id ? { scan_id } : undefined);
			        if (!scan) return;
			        applyScannedFolderSelection(scan);
			      } catch (error) {
			        console.error(error);
			        showPreviewPlaceholder(t('openFailed', { message: error?.message || String(error) }));
			      } finally {
			        if (typeof hideScanOverlay === 'function') hideScanOverlay();
			      }
			    }

		    function applyLocalFileSelection(fileList, sourceHint) {
		      const files = Array.from(fileList || []).filter((f) => f && typeof f === 'object');
		      if (!files.length) return;

	      cleanupDrawioPanHandlers();
	      cleanupPptxViewer();
	      cleanupMarpitNavigation();
	      cleanupPdfViewer();
	      cleanupMediaPreview();
	      cleanupWordToc();
	      cleanupExcelPreview();
		      try { singleImage.removeAttribute('src'); } catch {}

		      clearLocalFileCache();
		      hasUserSelection = true;

		      const rawPaths = files.map((file) => normalizeSelectedPath(file));
	      const hasDir = files.some((file) => Boolean(file.webkitRelativePath));
	      const commonRoot = hasDir ? getCommonRootFolder(rawPaths) : null;

	      const categories = {};
	      files.forEach((file, index) => {
	        let virtualPath = rawPaths[index];
	        if (commonRoot && virtualPath.startsWith(`${commonRoot}/`)) {
	          virtualPath = virtualPath.slice(commonRoot.length + 1);
	        }
	        if (!virtualPath) return;
	        const type = categorizePath(virtualPath);
	        if (!type) return;
	        if (!categories[type]) categories[type] = [];
	        categories[type].push(virtualPath);
	        localFilesByPath.set(virtualPath, file);
	      });

	      Object.values(categories).forEach((paths) => paths.sort(compareNames));

		      fileGroups = [{ path: '.', categories }];
		      currentCategory = 'all';
		      currentIndex = 0;
		      treeSearchTerm = '';
		      if (treeSearchInput) {
		        treeSearchInput.value = '';
		        treeSearchInput.disabled = false;
		      }
		      if (treeSearchClear) treeSearchClear.classList.add('hidden');

	      const label = commonRoot || (files.length === 1 ? files[0].name : (sourceHint || t('openedFiles')));
	      currentSourceKind = 'local';
	      currentSourceName = label || '';
	      updateCurrentSourceLabel();

	      renderCategoryFilters();
	      renderTree();

	      if (filteredFiles.length > 0) {
	        setCurrentFile(0);
	      } else {
	        showPreviewPlaceholder(t('emptyNoPreviewable'));
	      }
	    }

		    function setupOpenMenu() {
		      if (!openMenuBtn || !openMenuDropdown) return;

		      const closeRecentMenu = () => {
		        if (!openRecentDropdown) return;
		        openRecentDropdown.classList.remove('is-open');
		      };

		      const closeMenu = () => {
		        openMenuDropdown.classList.remove('is-open');
		        openMenuBtn.setAttribute('aria-expanded', 'false');
		        closeRecentMenu();
		      };

		      const toggleMenu = () => {
		        closeRecentMenu();
		        const isOpen = openMenuDropdown.classList.toggle('is-open');
		        openMenuBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
		      };

		      const renderRecentMenuMessage = (message) => {
		        if (!openRecentDropdown) return;
		        openRecentDropdown.textContent = '';
		        const placeholder = document.createElement('button');
		        placeholder.type = 'button';
		        placeholder.className = 'nav__dropdown-item';
		        placeholder.disabled = true;
		        placeholder.textContent = message;
		        openRecentDropdown.appendChild(placeholder);
		      };

		      const refreshRecentMenu = async () => {
		        if (!openRecentDropdown) return;
		        if (!tauriInvoke) {
		          renderRecentMenuMessage(t('openRecentEmpty'));
		          return;
		        }

		        renderRecentMenuMessage(t('openRecentLoading'));
		        let entries = [];
		        try {
		          const loaded = await tauriInvoke('get_recent_paths', { limit: 20 });
		          if (Array.isArray(loaded)) entries = loaded.filter((value) => typeof value === 'string' && value.trim());
		        } catch (error) {
		          console.error(error);
		          renderRecentMenuMessage(t('openRecentFailed'));
		          return;
		        }

		        if (!entries.length) {
		          renderRecentMenuMessage(t('openRecentEmpty'));
		          return;
		        }

		        openRecentDropdown.textContent = '';
		        entries.forEach((entry) => {
		          const path = String(entry).trim();
		          if (!path) return;
		          const button = document.createElement('button');
		          button.type = 'button';
		          button.className = 'nav__dropdown-item open-recent-item';
		          button.title = path;

		          const label = document.createElement('span');
		          label.className = 'open-recent-item__label';
		          label.textContent = getFileName(String(path).replace(/\\/g, '/')) || path;

		          const meta = document.createElement('span');
		          meta.className = 'open-recent-item__path';
		          meta.textContent = path;

		          button.appendChild(label);
		          button.appendChild(meta);

		          button.addEventListener('click', () => {
		            closeMenu();
		            const scan_id = showScanOverlay ? showScanOverlay() : null;
		            Promise.resolve()
		              .then(async () => {
		                const scan = await tauriInvoke(
		                  'scan_path',
		                  scan_id ? { path: String(path), scan_id } : { path: String(path) },
		                );
		                if (!scan) return;
		                applyScannedFolderSelection(scan);
		              })
		              .catch((error) => {
		                console.error(error);
		                showPreviewPlaceholder(t('openFailed', { message: error?.message || String(error) }));
		              })
		              .finally(() => {
		                if (typeof hideScanOverlay === 'function') hideScanOverlay();
		              });
		          });

		          openRecentDropdown.appendChild(button);
		        });
		      };

		      openMenuBtn.addEventListener('click', (event) => {
		        event.stopPropagation();
		        toggleMenu();
		      });

	      document.addEventListener('click', (event) => {
	        const target = event.target;
	        if (!target) return;
	        if (openMenuDropdown.contains(target) || openMenuBtn.contains(target)) return;
	        closeMenu();
	      });

	      document.addEventListener('keydown', (event) => {
	        if (event.key === 'Escape') closeMenu();
	      });

		      if (openFolderBtn) {
		        openFolderBtn.addEventListener('click', () => {
		          closeMenu();
		          void requestOpenFolder();
		        });
		      }

			      if (openFileBtn) {
			        openFileBtn.addEventListener('click', () => {
			          closeMenu();
			          void requestOpenFile();
			        });
			      }

			      if (openRecentBtn) {
			        if (!tauriInvoke) {
			          openRecentBtn.disabled = true;
			        }
			        openRecentBtn.addEventListener('click', () => {
			          if (!openRecentDropdown) return;
			          if (!tauriInvoke) return;
			          const isOpen = openRecentDropdown.classList.toggle('is-open');
			          if (isOpen) {
			            openRecentDropdown.style.top = `${openRecentBtn.offsetTop}px`;
			            void refreshRecentMenu();
			          }
			        });
			      }

			      if (openFileInput) {
			        openFileInput.addEventListener('change', (event) => {
			          const input = event.target;
		          const files = input?.files;
		          if (files && files.length) applyLocalFileSelection(files, t('openedFiles'));
	          if (input) input.value = '';
	        });
	      }

	      if (openFolderInput) {
	        openFolderInput.addEventListener('change', (event) => {
	          const input = event.target;
	          const files = input?.files;
	          if (files && files.length) applyLocalFileSelection(files, t('openedFolder'));
	          if (input) input.value = '';
	        });
	      }
		    }
	
		    setupOpenMenu();

			    function initializeApp() {
			      clearLocalFileCache();
			      hasUserSelection = false;
			      fileGroups = [];
			      filteredFiles = [];
		      currentCategory = 'all';
		      currentIndex = 0;
		      treeSearchTerm = '';
		      currentSourceKind = 'none';
		      currentSourceName = '';
		      updateCurrentSourceLabel();
		      if (treeSearchInput) {
		        treeSearchInput.value = '';
		        treeSearchInput.disabled = true;
		      }
		      if (treeSearchClear) treeSearchClear.classList.add('hidden');
		      renderCategoryFilters();
		      renderTree();
		      if (previewTitleEl) previewTitleEl.textContent = t('selectFolder');
		      if (previewSubtitleEl) previewSubtitleEl.textContent = t('selectFolderHint');
		      showPreviewPlaceholder(t('selectFolderHint'));
			    }
			    initializeApp();

					    async function tryOpenFromCli() {
				      if (!tauriInvoke) return;

				      let targetPath = null;
			      try {
			        targetPath = await tauriInvoke('get_cli_open_target');
			      } catch (error) {
			        console.error(error);
			        return;
			      }

				      if (!targetPath || hasUserSelection) return;

				      const scan_id = showScanOverlay ? showScanOverlay() : null;
				      try {
				        const scan = await tauriInvoke(
				          'scan_path',
				          scan_id ? { path: String(targetPath), scan_id } : { path: String(targetPath) },
				        );
				        if (!scan) return;
				        applyScannedFolderSelection(scan);
				      } catch (error) {
				        console.error(error);
				        showPreviewPlaceholder(t('openFailed', { message: error?.message || String(error) }));
				      } finally {
				        if (typeof hideScanOverlay === 'function') hideScanOverlay();
				      }
					    }
				    void tryApplySiteNameFromCli();

					    function applySiteName(siteName) {
					      const value = String(siteName || '').trim();
					      if (!value) return;
	
					      const prefix = `${APP_PREFIX} - `;
					      const siteNamePart = value.toLowerCase().startsWith(prefix.toLowerCase())
					        ? value.slice(prefix.length).trim()
					        : value;
					      if (!siteNamePart) return;
	
					      currentSiteNamePart = siteNamePart;
					      currentSiteNameIsDefault = (
					        currentSiteNamePart === I18N.zh.siteNameDefault ||
					        currentSiteNamePart === I18N.en.siteNameDefault
					      );
					      applyAppTitle(currentSiteNamePart);
					    }

				    async function tryApplySiteNameFromCli() {
			      if (!tauriInvoke) return;

			      try {
			        const siteName = await tauriInvoke('get_cli_site_name');
			        applySiteName(siteName);
			      } catch (error) {
			        console.error(error);
			      }
				    }
				    void tryOpenFromCli();
		
			  </script>
</body>
</html>
